<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">

	<Plugin>
		<ShortDescription>fb-contrib plugin</ShortDescription>
		<Details>
			<![CDATA[
			<p>
			This plugin contains FindBugs detectors from the fb-contrib project
			</p>
			]]>
	    </Details>
	</Plugin>

	<!-- Detectors -->

	<Detector class="com.mebigfatguy.fbcontrib.collect.CollectStatistics">
		<Details>
			<![CDATA[
			<p>Collects statistics for other detectors</p>
			]]>
    	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InefficientStringBuffering">
		<Details>
			<![CDATA[
			<p> Looks for appending strings inside of calls to StringBuffer or StringBuilder append.</p>
			<p> <pre>
				StringBuffer sb = new StringBuffer();
				sb.append(a + b);
				return sb.toString();
			</pre></p>
			<p>It is a fast detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SyncCollectionIterators">
		<Details>
			<![CDATA[
			<p> Looks for use of iterators on synchronized collections built from the Collections class</p>
			<p> As the collection in question was built thru Collections.synchronizedXXX, an assumption
			is made that this collection must be multithreaded safe. However, iterator access is used, 
			which is explicitly unsafe. When iterators are to be used, synchronization should be done manually.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CyclomaticComplexity">
		<Details>
			<![CDATA[
			<p> Calculates the McCabe Cyclomatic Complexity measure and reports methods that have an
			excessive value. This report value can be set with system property 'fb-contrib.cc.limit'.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OverlyConcreteParameter">
		<Details>
			<![CDATA[
			<p> Looks for parameters that are defined by classes, but only use methods defined by an
			implemented interface or super class. Relying on concrete classes in public signatures causes cohesion,
			and makes low impact changes more difficult.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ListIndexedIterating">
		<Details>
			<![CDATA[
			<p> Looks for for loops that iterate over a java.util.List using an integer index, and get,
			rather than using an Iterator. An iterator may perform better depending List implementation, 
			but more importantly will allow the code to be converted to other collections type.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedCollectionContents">
		<Details>
			<![CDATA[
			<p> Looks for collections or arrays that hold objects that are unrelated thru class or
			interface inheritance other than java.lang.Object. Doing so, makes for brittle code,
			relying either on positional correspondence for type, or a reliance on instanceof to
			determine type. A better design usually can be had by creating a seperate class,
			which defines the different types required, and add an instance of that class to the
			collection, or array.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeclaredRuntimeException">
		<Details>
			<![CDATA[
			<p> Looks for methods that declare Runtime exceptions in their throws clause. While doing
			so is not illegal, it may represent a misunderstanding as to the exception in question.
			If a RuntimeException is declared, it implies that this exception type is expected to happen,
			which if true, should be handled in code, and not propogated. </p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ClassEnvy">
		<Details>
			<![CDATA[
			<p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em></p>
			<p> Looks for methods that use a high percentage of methods from another class over it's own
			methods. When this is the case, it is often better to implement this method in that other class,
			by refactoring the class to accept parameters it needs from the source class.
			The reporting percentage can be set with system property 'fb-contrib.ce.percent'.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LiteralStringComparison">
		<Details>
			<![CDATA[
			<p> Looks for methods that compare strings against literal strings, where the literal string
			is passed as the parameter. If the .equals or .compareTo is called on the literal itself, passing
			the variable as the parameter, you avoid the possibility of a NullPointerException.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PartiallyConstructedObjectAccess">
		<Details>
			<![CDATA[
			<p> Looks for constructors of non final classes that make method calls to non final methods.
			As these methods could be overridden, the overridden method will be accessing an object that
			is only partially constructed, perhaps causing problems.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DubiousListCollection">
		<Details>
			<![CDATA[
			<p> looks for fields that are implementations of java.util.List, but that are used in a set-like fashion.
			Since lookup type operations are performed using a linear search for Lists, the performance for large
			Lists will be poor. Consideration should be made as to whether these fields should be sets. In the
			case that order is important, consider using LinkedHashSet.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ParallelLists">
		<Details>
			<![CDATA[
			<p> Looks for classes that maintain two or more lists or arrays associated one-for-one through the same index
			to hold two or more pieces of related information. It would be better to create a new class that holds
			all of these pieces of information, and place instances of this class in one list.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FinalParameters">
		<Details>
			<![CDATA[
			<p>Looks for methods that correctly do not write to a parameter. To help document this, and to perhaps
			help the jvm optimize the invocation of this method, you should consider defining these parameters
			as final.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractClassEmptyMethods">
		<Details>
			<![CDATA[
			<p> Looks for abstract classes that define empty methods or methods that simply throw an 
			exception. Since this is an abstract class, it may be cleaner to simple define this method
			as abstract, so that correct subclass behaviour is enforced.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ManualArrayCopy">
		<Details>
			<![CDATA[
			<p> Looks for methods that copy data from one array to another using a loop. It is
			better performing to use System.arraycopy to do such copying as this is a native method.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FloatingPointLoops">
		<Details>
			<![CDATA[
			<p> Looks for methods that use floating point indexes for loops. Since floating point
			math is inprecise, rounding errors will occur each time through the loop causing
			hard to find problems. It is usually better to use integer indexing, and calculating
			the correct floating point value from the index.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonCollectionMethodUse">
		<Details>
			<![CDATA[
			<p> Looks for method calls to collection classes where the method is not defined by the Collections
			interface, and an equivalent method exists in the interface. Examples include:<br>
			<table border="1">
				<tr><th>Old Method</th><th>New Method</th></tr>
				<tr><td>Hashtable.contains</td><td>Map.containsValue</td></tr>
				<tr><td>Hashtable.elements</td><td>Map.elements</td></tr>
				<tr><td>Hashtable.keys</td><td>Map.keySet</td></tr>
				<tr><td>Vector.addElement</td><td>List.add</td></tr>
				<tr><td>Vector.elementAt</td><td>List.get</td></tr>
				<tr><td>Vector.insertElementAt</td><td>List.add</td></tr>
				<tr><td>Vector.removeAllElements</td><td>List.clear</td></tr>
				<tr><td>Vector.removeElement</td><td>List.remove</td></tr>
				<tr><td>Vector.removeElementAt</td><td>List.remove</td></tr>
				<tr><td>Vector.setElementAt</td><td>List.set</td></tr>
			</table>
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingAutoboxedOverloading">
		<Details>
			<![CDATA[
			<p> Looks for methods that have the same signature, except where one uses a 
			Character parameter, and the other uses an int, long, float, double parameter.
			Since autoboxing is available in 1.5 one might assume that
			<pre>
			test('a')
			</pre>
			would map to
			<pre>
			public void test(Character c)
			</pre>
			but instead maps to one that takes an int long, float or double.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbnormalFinallyBlockReturn">
		<Details>
			<![CDATA[
			<p> Looks for methods that have finally blocks that return values
			or throw exceptions. This code will swallow normal program flow and 
			hide real program logic.
			</p>
			<p>It is a fast detector</p>			
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticMethodInstanceInvocation">
		<Details>
			<![CDATA[
			<p> Looks for methods that make static method calls using an instance reference.
			For documentation purposes, it is better to call the method using the class name.
			This may represent a change in definition that should be noticed.
			</p>
			<p>It is a fast detector</p>			
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpuriousThreadStates">
		<Details>
			<![CDATA[
			<p> Looks for methods that call wait, notify or notifyAll on an instance of a 
			java.lang.Thread. Since the internal workings of the threads is to synchronize on the
			thread itself, introducing client calls will confuse the thread state of the object
			in question, and will cause spurious thread state changes, either waking threads up
			when not intended, or removing the the thread from the runnable state.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessAutoboxing">
		<Details>
			<![CDATA[
			<p> Looks for methods that pass a primitive wrapper class object, to the
			same classes Constructor. Patterns found are:
			<ul>
				<li>new Boolean(Boolean)</li>
				<li>new Byte(Byte)</li>
				<li>new Character(Character)</li>
				<li>new Short(Short)</li>
				<li>new Integer(Integer)</li>
				<li>new Long(Long)</li>
				<li>new Float(Float)</li>
				<li>new Double(Double)</li>
			</ul>
			</p>
			<p>It also looks for calls to BoxedClass.valueOf(x) where X is already a Boxed class</p>
			<p>It also looks for calls to BoxedClass.valueOf(myString).boxedValue(), When instead it is
			simpler to use BoxedClass.parseBoxed(myString)</p>
			<p>It is a fast detector</p>			
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryStoreBeforeReturn">
		<Details>
			<![CDATA[
			<p>Looks for methods that store the return result in a local variable, and
			then immediately returns that local variable.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CopiedOverriddenMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that are direct copies of the implementation in the super class</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayBasedCollections">
		<Details>
			<![CDATA[
			<p>Looks for methods that use arrays for items in the keyset of a map, or as
			an element of a set, or in a list when using the contains method. Since arrays
			do not, and cannot define an equals method, reference equality is used for these
			collections, which is probably not desired. If it is, consider using the IdentityHashMap
			class when using Maps in this case, to better document your intentions.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OrphanedDOMNode">
		<Details>
			<![CDATA[
			<p>Looks for methods that create DOM Nodes but do not add them to any DOM Document.</p>
			<p>It is a fast Detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractOverriddenMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that are declared as abstract that override concrete methods in a
			super class. Doing this casts away the implementation of the super class, and breaks
			the contract as set forth by the parent class.</p>
			<p>It is a fast Detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CustomBuiltXML">
		<Details>
			<![CDATA[
			<p>Looks for methods that build xml based strings by concatenation strings
			and custom values together. Doing so makes brittle code, that is difficult to 
			modify, validate and understand. It is cleaner to create external xml files that are
			transformed at runtime, using parameters set through Transformer.setParameter.
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedSynchronizedBlock">
		<Details>
			<![CDATA[
			<p>Looks for methods that are implemented using synchronized blocks, but are overly
			synchronized because the beginning of the block only accesses local variables,
			and not member variables, or this.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConstantListIndex">
		<Details>
			<![CDATA[
			<p>Looks for methods that access arrays or classes that implement java.util.List
			using a constant integer for the index. This is often a typo intented to be a loop
			variable, but if specific indices mean certain things, perhaps a first class object
			would be a better choice for a container.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SloppyClassReflection">
		<Details>
			<![CDATA[
			<p>Looks for methods that use Class.forName("XXX") to load a class object
			for a class that is already referenced by this class. It is simpler to just use
			XXX.class, and doing so protects the integrity of this code from such transformations
			as obfuscation. Use of Class.forName should only be used when the class in question
			isn't already statically bound to this context.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayWrappedCallByReference">
		<Details>
			<![CDATA[
			<p>Looks for methods that use an array of length one to pass a variable to achieve call
			by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SluggishGui">
		<Details>
			<![CDATA[
			<p>Looks for methods that implement awt or swing listeners and perform time 
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. It is better to 
			use a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessInstanceRetrieval">
		<Details>
			<![CDATA[
			<p>Looks for methods that call a method to retrieve a reference to an object, 
			to use to load a constant. It is simpler and more performant to access the
			static variable directly from the class itself.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DateComparison">
		<Details>
			<![CDATA[
			<p> Looks for inefficient comparison of Date objects using two comparisons when one would do.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousWaitOnConcurrentObject">
		<Details>
			<![CDATA[
			<p>Looks for calls to the wait method on mutexes defined in the java.util.concurrent 
			package where it is likely that await was intended.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.JDBCVendorReliance">
		<Details>
			<![CDATA[
			<p>Looks for uses of jdbc vendor specific classes and methods making the database 
			access code non portable.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleMemoryBloat">
		<Details>
			<![CDATA[
			<p>Looks for classes that maintain collections or StringBuffer/StringBuilders in 
			static member variables, and that do not appear to provide a way to clear or remove 
			items from these members. Such class fields are likely causes of memory bloat.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LocalSynchronizedCollection">
		<Details>
			<![CDATA[
			<p>Looks for allocations of synchronized collections that are stored in local 
			variables, and never stored in fields or returned from methods. As local variables 
			are by definition thread safe, using synchronized collections in this context 
			makes no sense.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FieldCouldBeLocal">
		<Details>
			<![CDATA[
			<p>Looks for classes that define fields that are used in a locals only fashion, 
			specifically private fields that are accessed first in each method with a 
			store vs. a load.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonOwnedSynchronization">
		<Details>
			<![CDATA[
			<p>Looks for methods that synchronize on variables that are not owned by the
			current class. Doing this causes confusion when two classes use the same variable
			for their own synchronization purposes. For cleanest separation of interests, only
			synchronize on private fields of the class. Note that 'this' is not owned by
			the current class and synchronization on 'this' should be avoided as well.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonRecycleableTaglibs">
		<Details>
			<![CDATA[
			<p>Looks for tag libraries that are not recycleable because backing members 
			of taglib attributes are set in areas besides the setter method for the attribute.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.Section508Compliance">
		<Details>
			<![CDATA[
				<p>Looks for violation of Section 508, Accessibility for People with disabilities Act.
				</p>
				<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseEnumCollections">
		<Details>
			<![CDATA[
			<p>Looks for use of sets and maps using enums. It is more efficient to use EnumSet or EnumMap</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SQLInLoop">
		<Details>
			<![CDATA[
			<p>Looks for the execution of sql queries inside a loop. This pattern tends to be inefficient,
			and often can be improved upon, by collecting all the keys needed for the query and issuing just
			one query using an in clause with all the keys for all the queries previously needed in the loop.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessMemberCollectionSynchronization">
		<Details>
			<![CDATA[
			<p>Looks for classes that define private synchronized collections as static or instance 
			members, that are only altered in a static initializer or constructor. Since the multithreaded
			use of this collection is read-only, the use of synchronization is unnecessary.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InheritanceTypeChecking">
		<Details>
			<![CDATA[
			<p>Looks for if/else blocks where a series of them use instanceof on the same 
			variable to determine what to do. If these classes are related by inheritance,
			this often is better handled through calling a single overridden method.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticArrayCreatedInMethod">
		<Details>
			<![CDATA[
			<p>Looks for creation of arrays in methods using constant values. These arrays
			will need to be recreated each time the method is called. These arrays should probably
			be defined as static fields, instead</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossiblyRedundantMethodCalls">
		<Details>
			<![CDATA[
			<p>Looks for calls of the same method on the same object when that object hasn't changed.
			This often is redundant, and the second call can be removed, or combined.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseToArray">
		<Details>
			<![CDATA[
			<p>Looks for code that builds an array of values from a collection, by manually looping
			over the elements of the collection, and adding them to the array. It is simpler and
			cleaner to use mycollection.toArray(new type[mycollection.size()].</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LostExceptionStackTrace">
		<Details>
			<![CDATA[
			<p>Looks for methods that catch exceptions, and then throw a different exception,
			without embedding the original exception in the thrown one. Doing so, hides the real
			source of the exception, making debugging and fixing these problems difficult.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseCharacterParameterizedMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that pass single character string constants as parameters to 
			methods that alternatively have an overridden method that accepts a character instead.
			It is easier for the method to handle a single character than a String.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.TailRecursion">
		<Details>
			<![CDATA[
			<p>Looks for methods that make a recursive call to itself as the last statement in the
			method. This tail recursion could be converted into a simple loop which would improve
			the performance and stack requirements.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedReturnValues">
		<Details>
			<![CDATA[
			<p>Looks for methods that are defined to return Object, and return different types of
			objects based on different code paths. If this method is not based on a interface or
			superclass, it is suggested to change the return type to a type that would accomodate
			all kinds of return types.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleIncompleteSerialization">
		<Details>
			<![CDATA[
			<p>Looks for classes that don't handle serialization of parent class member fields 
			when the class in question is serializable but is derived from a non serializable 
			classes.</p> 
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousComparatorReturnValues">
		<Details>
			<![CDATA[
			<p>Looks for class that implement Comparator or Comparable, and whose compare or compareTo
 			methods return constant values only, but that don't represent the three possible choice
			(a negative number, 0, and a positive number).</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SillynessPotPourri">
		<Details>
			<![CDATA[
			<p>Looks for a potpourri of small problems that do not fit into a common pattern.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedAssignmentScope">
		<Details>
			<![CDATA[
			<p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em>
			Looks for assignments to variables in a scope larger than it's use. As long as the evaluation of the assignment
			does not have side effects, the assignment can be moved into the inner scope where it is used.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpoiledChildInterfaceImplementor">
		<Details>
			<![CDATA[
			<p>Looks for classes that implement interfaces by relying on methods being 
			implemented in superclasses, even tho the superclass knows nothing about
			the interface being implemented by the child.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeletingWhileIterating">
		<Details>
			<![CDATA[
			<p>Looks for deletion of items from a collection using the remove method
			of the collection at the same time that the collection is being iterated on. If
			this occurs the iterator will become invalid and throw a ConcurrentModificationException.
			Instead, the remove should be called on the iterator itself.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseSplit">
		<Details>
			<![CDATA[
			<p>Looks for code that builds an array by using a StringTokenizer to break up
			a string and place individual elements into an array. It is simpler to use
			String.split instead.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousJDKVersionUse">
		<Details>
			<![CDATA[
			<p>Looks for calls to classes and methods that do not exist in the JDK for which this class is
			compiled. This can happen if you specify the -source and -target options of the javac compiler, and
			specify a target that is less than the jdk version of the javac compiler.</p>
			<p>It is a slow detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseAddAll">
		<Details>
			<![CDATA[
			<p>Looks for loops that transfers the contents of one collection to another. These collection sources might
			be local variables or member fields, including sets, maps key/values, lists, or arrays. It is simpler to 
			just use the addAll method of the collection class. In the case where the source is an array, you can use
			Arrays.asList(array), and use that as the source to addAll.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MethodReturnsConstant">
		<Details>
			<![CDATA[
			<p>Looks for private or static methods that only return one constant value. Since there is no
			chance for derived classes overriding this behavior, the return of a constant value 
			seems dubious.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessCustomSerialization">
		<Details>
			<![CDATA[
			<p>Looks for classes that implement the Serializable interface and implement the
			standard readObject and writeObject methods by simply deferring to the Stream 
			parameter's defaultReadObject or defaultWriteObject and nothing else. As this is the
			built in behavior, these methods are not needed.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MisleadingOverloadModel">
		<Details>
			<![CDATA[
			<p>Looks for classes that define both static and instance methods with the same name.
			As each type represents a different use model, it doesn't make sense that this name
			would be overloaded, and will confuse users of the class.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ExceptionSoftening">
		<Details>
			<![CDATA[
			<p>Looks for methods that catch checked exceptions, and throw unchecked
			exceptions in their place. There are several levels of concern. Least
			concerning are methods constrained by interface or super class contracts
			not to throw checked exceptions but appear owned by the same author. Next
			are methods constrained by interface or super class contracts and throw other
			types of checked exceptions. Most egregious are method not constrained by any interface
			or superclass contract.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingFunctionSemantics">
		<Details>
			<![CDATA[
			<p>Looks for methods that return a parameter after modifying that parameter.
			Doing this will confuse the user of this method, as it will be assumed that the 
			passed in argument is different than the output, or at least won't be changed.
			If the purpose of this method is just to modify the parameter, this method should
			probably be changed to have a void return type. If you must return a variable, perhaps
			a clone of the parameter should be returned.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.JUnitAssertionOddities">
		<Details>
			<![CDATA[
			<p>Looks for junit test case methods that use assertions with odd parameters.
			Including in this is:
			<ul>
				<li>Passing a constant as the second (actual) parameter</li>
				<li>not using the three parameter version of asserts for doubles</li>
				<li>Passing true or false as the first parameter instead of using assertTrue, or assertFalse</li>
			</ul>
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousCloneAlgorithm">
		<Details>
			<![CDATA[
			<p>Looks for implementations of clone where an assignment is made to a field of the
			source object. It is likely that that store should have occurred on the cloned object, as
			the clone operation is almost always considered read only.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.WeakExceptionMessaging">
		<Details>
			<![CDATA[
			<p>Looks for exceptions that are thrown with static strings as messages. Using static strings
			doesn't differentiate one use of this method versus another, and so it may be difficult
			to determine how this exception occurred without showing context.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousClusteredSessionSupport">
		<Details>
			<![CDATA[
			<p>Looks for code that fetches a complex object from an HttpSession attribute, modifies the
			object, but does not call setAttribute again on this object. This will not inform the application server
			that this object has changed, and thus will not correctly replicate these changes across the cluster.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LoggerOddities">
		<Details>
			<![CDATA[
			<p>Looks for odd patterns of use of Logger classes from either log4j, slf4j or commons logging.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.IncorrectInternalClassUse">
		<Details>
			<![CDATA[
			<p>Looks for classes that rely on internal classes in the various apis or libraries. As these 
			classes are not officially released from the api vendor, they are subject to change or removal, and thus,
			should not be counted on.</p>
			Packages that shouldn't be used are:
			<ul>
				<li>com.sun.xxx</li>
				<li>org.apache.xerces.xxx</li>
				<li>org.apache.xalan.xxx</li>
			</ul>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DubiousSetOfCollections">
		<Details>
			<![CDATA[
			<p>Looks for sets or keySets of maps that contain other collections. As typically collections calculate
			their hashCode, equals and compareTo methods by iterating the collection and evaluating the same function
			on each item in the collection, this can be costly from a performance point of view.</p>
			<p>In addition, using a set, or keySet of a map, infers that you will be looking for items based on 
			the value of a collection, which seems dubious at best.</p>
			<p>Finally, as collections are often modified, This may cause problems if the collection is modified,
			thus changing hashCodes, etc, while the collection is in the set.</p>
			<p>If you wish to keep a collection of collections, the outer collection should probably be a list
			to avoid these problems</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BogusExceptionDeclaration">
		<Details>
			<![CDATA[
			<p>Looks for constructors, static methods and private methods that declare that they throw 
			checked exceptions that the actual code never throws. Since these methods can't be overridden,
			there is no reason to add these exceptions to the method declaration.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryNewNullCheck">
		<Details>
			<![CDATA[
			<p>Looks for allocations of objects, and then immediately checking to see if the
			object is null, or non null. As the new operator is guaranteed to eiher succeed, or throw
			an exception, this null check is useless, and denotes a misunderstanding as to how
			the jvm works. You can remove this guard.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeprecatedTypesafeEnumPattern">
		<Details>
			<![CDATA[
			<p>Looks for classes that appear to implement the old style type safe enum pattern 
			that was used before java added Enum support to the language. Since this class is 
			compiled with java 1.5 or later, it would be simpler to just use java enums</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StutteredMethodArguments">
		<Details> experimental="true"
			<![CDATA[
			<p>Looks for method calls that pass the same value for two separate parameters, where
			those arguments are not constants. Often this is a cut/paste mistake, but if not, it is
			confusing why you would pass the same value for two arguments.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.TristateBooleanPattern">
		<Details>
			<![CDATA[
			<p>Looks for methods that are declared to return a Boolean, but return a null
			value. As this now allows the method to return 3 values, the use of Boolean is
			dubious. It would be better to just define a new enumeration with three values,
			and return that.</p>
			<p>It is a fast detector</p>
			]]>	
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousUninitializedArray">
		<Details>
			<![CDATA[
				<p>Looks for methods that return arrays that are allocated but not initialized
				in this method. While it's possible that the calling method will do the work of
				initializing the array, it is not a usual pattern, and it suspected that this array
				was just forgotten to be initialized.</p>
				<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InappropriateToStringUse">
		<Details>
			<![CDATA[
				<p>Looks for methods that perform algorithmic operations on Strings that are returned
				from a toString() method. As toString should only be used for debug/trace purposes, it
				shouldn't be used for algorithm use.</p>
				<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InconsistentKeyNameCasing">
		<Details>
			<![CDATA[
				<p>Looks for methods that use the same name with different casing to access objects in HttpRequest parameters
				and attributes. As these parameter names are case sensitive this will lead to confusion.</p>
				<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OverzealousCasting">
		<Details>
			<![CDATA[
			<p>Looks for manual casts of objects that are more specific then needed as the value is assigned
			to a class or interface higher up in the inheritance chain. You only need to cast to that class
			or interface.</p>
			<p>It is a fast detector</p>
			]]>	
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PoorlyDefinedParameter">
		<Details>
			<![CDATA[
			<p>Looks for non derivable methods that declare parameters and then cast those
			parameters to more specific types in the method. This is misleading and dangerous
			as you are not documenting through parameter types what is necessary for these
			parameters to function correctly.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonSymmetricEquals">
		<Details>
			<![CDATA[
			<p>Looks for classes that break the fundamental rule of equivalence, which is
			symmetry. If a equals b, then b equals a. While it is usually wrong to allow
			equals to compare different types, at the very least you should make sure that
			each class knows about each other and is able to compare themselves with each other.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ContraVariantArrayAssignment">
		<Details>
			<![CDATA[
			<p>Finds contravariant array assignments. Since arrays are mutable data structures, their use 
			must be restricted to covariant or invariant usage</p>
			
			<pre>
			class A {}
			class B extends A {}
			
			 B[] b = new B[2];
			 A[] a = b;
			 a[0] = new A(); // results in ArrayStoreException (Runtime)
			</pre>
			<p>It is a fast detector</p>            
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonFunctionalField">
		<Details>
			<![CDATA[
		 	<p>Looks for fields in serializable classes that are defined as both final and
			transient. As a transient field is not initialized when streamed, and is not 
			initialized in a constructor, it will remain null because it is defined final.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousNullGuard">
		<Details>
	 		<![CDATA[
 			<p>Looks for code that checks to see if a field or local variable is not null,
 			before entering a code block either an if, or while statement, and then reassigns that 
 			field or local variable. It is likely that guard should have been to see if that
 			field or local variable is null, not, not null</p>
 			<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MoreDumbMethods">
		<Details>
	            	<![CDATA[
	            	<p>This detector looks for calls to more pointless or deprecated methods.</p>
	            	<p>It is a fast detector</p>
	            	]]>
	          </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionOnObjectMethods">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for reflective calls on methods that are found java.lang.Object.
	 		As these methods are always available, there is no reason to use reflection to call them.
	 		</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ImproperPropertiesUse">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for java.util.Properties use where values other than String
	 		are placed in the properties object. As the Properties object was intended to be a 
	 		String to String only collection, putting other types in the Properties object is 
	 		incorrect, and takes advantage of a poor design decision by the original Properties class
	 		designers to derive from Hashtable, rather than using aggregation.</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleConstantAllocationInLoop">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for allocations of objects using the default constructor in a loop, where
	 		the object allocated is never assigned to any object that is used outside the loop.
	 		It is possible that this allocation can be done outside the loop to avoid excessive garbage.</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.WriteOnlyCollection">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for allocations and initializations of java collections, but that are never
	 		read from or accessed to gain information. This represents a collection of no use, and most probably
	 		can be removed. It is similar to a dead local store.</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseVarArgs">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for definitions of methods that have an array as the last parameter.
	 		Since this class is compiled with java 1.5 or better, it would be more flexible for clients of this
	 		method to define this parameter as a vararg parameter</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleUnsuspectedSerialization">
		<Details>
	 		<![CDATA[
	 		<p>This detector looks for code that serializes objects that are non-static inner
	 		classes of other classes. Since there is a reference to the containing class, this class will be serialized as well.
	 		It is often the case that this is not what is wanted, and will cause much more data to be serialized
	 		than is necessary.</p>
	 		<p>It is a fast detector</p>
	 		]]>
	 	</Details>
	</Detector>
	
	<Detector class="com.mebigfatguy.fbcontrib.detect.SideEffectConstructor">
		<Details>
			<![CDATA[
			<p>This detector looks for object creation where the object isn't assigned to any variable or
			field. This implies that the class operates through side effects in the constructor, which makes
			for difficult to maintain code.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>
	
	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousGetterSetterUse">
		<Details>
			<![CDATA[
			<p>This detector looks for java bean getter-setter use where the value of a property is set
			with the value retrieved from the same bean's correllary getter, like this:</p>
			<pre>
				person.setAge(person.getAge());
			</pre>
			<p>Typically this is a copy paste typo.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>
	
	<Detector class="com.mebigfatguy.fbcontrib.detect.LingeringGraphicsObjects">
		<Details>
			<![CDATA[
			<p>This detector looks for creation of java.awt.Graphics object that do not have the
			.dispose() method called on them when finished. These objects will be cleaned up by 
			the Garbage collector, bug given the likelyhood that large numbers of these objects can
			be created in a short period of time, it is better to dispose them as soon as possible
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>
	
	<Detector class="com.mebigfatguy.fbcontrib.detect.StackedTryBlocks">
		<Details>
			<![CDATA[
			<p>This detector looks for two or more try catch blocks that are consecutive 
			and catch the same kind of exception, and each catch block mandatorily throws 
			the same exception. These two catch blocks can and should be made into one 
			catch block to simply the code.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsEqualsBuilderToEquals">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for Commons-lang EqualsBuilder where the
            result of equals() is returned instead of calling the method isEquals().</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
   <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsHashcodeBuilderToHashcode">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for Commons-lang HashCodeBuilder where the
            result of hashCode() is returned instead of calling the method toHashCode().</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
   <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsStringBuilderToString">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for Commons-lang ToStringBuilder where the
            result of toString() is returned without an intermediate invocation of toString().</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.CompareClassNameEquals">
        <Details>
            <![CDATA[
            <p> In a JVM, Two classes are the same class (and consequently the same type) if
            they are loaded by the same class loader, and they have the same fully
            qualified name [JVMSpec 1999].
            
            Comparing class name ignores the class loader.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.BackportReusePublicIdentifiers">
        <Details>
            <![CDATA[
            <p> Detects use of Backport Utils concurrent classes. Updated/Efficient version of these
            classes are available in versions of the JDK 5.0 and higher, and these
            classes should only be used if you are targeting JDK 1.4 and lower.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.CloneUsability">
        <Details>
            <![CDATA[
            <p> Looks for classes that implement clone() that do not specialize the return value, and do
            not swallow CloneNotSupportedException. Not doing so makes the clone method not as simple to use, 
            and should be harmless to do so.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
        
    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingArrayAsList">
        <Details>
            <![CDATA[
            <p> Looks for calls to Arrays.asList where the parameter is a primitive array.
            This does not produce a list that holds the primitive boxed values, but a list of
            one item, the array itself.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.PresizeCollections">
            <Details>
            <![CDATA[
            <p> Looks for methods that create collections using the default constructor,
            even though the number of elements that will be placed in the collection is known
            apriori, and thus could be pre-allocated. Not doing so just causes more intermediate
            reallocations which is unnecessary.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
	<!-- BugPattern -->

	<BugPattern type="ISB_INEFFICIENT_STRING_BUFFERING">
		<ShortDescription>Method passes simple concatenating string in StringBuffer or StringBuilder append</ShortDescription>
		<LongDescription>Method {1} passes simple concatenating string in StringBuffer or StringBuilder append</LongDescription>
		<Details>
			<![CDATA[
			<p> This method uses StringBuffer or StringBuilder append to concatenate strings. However, it passes the result
			of doing a simple String concatenation to one of these append calls, thus removing any performance gains
			of using the StringBuffer or StringBuilder class.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="ISB_EMPTY_STRING_APPENDING">
		<ShortDescription>Method concatenates an empty string to effect type conversion</ShortDescription>
		<LongDescription>Method {1} concatenates an empty string to effect type conversion</LongDescription>
		<Details>
			<![CDATA[
			<p> This method concatenates an empty string with a literal value, in order to convert
			the literal value into a string. It is more efficient to use String.valueOf() to do the same
			thing as you do not incur the cost of creating a StringBuffer/Builder and calling methods on it
			to accomplish this.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="SCI_SYNCHRONIZED_COLLECTION_ITERATORS">
		<ShortDescription>Method creates iterators on synchronized collections</ShortDescription>
		<LongDescription>Method {1} creates iterators on synchronized collections</LongDescription>
		<Details>
			<![CDATA[
			<p> This method uses a synchronized collection, built from Collections.synchronizedXXXX, but accesses it 
			through an iterator. Since an iterator is by definition, multithreaded unsafe, this is a conflict in
			concept. When using iterators, you should do the synchronization manually.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="CC_CYCLOMATIC_COMPLEXITY">
		<ShortDescription>Method is excessively complex</ShortDescription>
		<LongDescription>Method {1} is excessively complex</LongDescription>
		<Details>
			<![CDATA[
			<p> This method has a high cyclomatic complexity figure, which calculates the number of branch
			points. It is likely difficult to test, and is brittle to change. Consider refactoring this 
			method into several to reduce the risk.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="OCP_OVERLY_CONCRETE_PARAMETER">
		<ShortDescription>Method needlessly defines parameter with concrete classes</ShortDescription>
		<LongDescription>Method {1} needlessly defines parameter with concrete classes</LongDescription>
		<Details>
			<![CDATA[
			<p> This method uses concrete classes for parameters when only methods defined in an implemented
			interface or super class are used. Consider increasing the abstraction of the interface to
			make low impact changes easier to accomplish in the future.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="LII_LIST_INDEXED_ITERATING">
		<ShortDescription>Method uses integer based for loops to iterate over a List</ShortDescription>
		<LongDescription>Method {1} uses integer based for loops to iterate over a List</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses an integer based for loop to iterator over a java.util.List, by calling
			List.get(i) each time thru the loop. The integer is not used for other reasons. It is better
			to use an Iterator instead, as depending on List implementation, iterators can perform better, 
			and they also allow for exchanging of other collection types without issue.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCC_UNRELATED_COLLECTION_CONTENTS">
		<ShortDescription>Method adds unrelated types to collection or array</ShortDescription>
		<LongDescription>Method {1} adds unrelated types to collection or array</LongDescription>
		<Details>
			<![CDATA[
			<p>This method adds unrelated objects to a collection or array, requiring careful and brittle
			data access to that collection. Create a separate class with properties needed, and add
			an instance of this class to the collection or array, if possible.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DRE_DECLARED_RUNTIME_EXCEPTION">
		<ShortDescription>Method declares RuntimeException in throws clause</ShortDescription>
		<LongDescription>Method {1} declares RuntimeException in throws clause</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares a RuntimeException derived class in it's throws clause.
			This may indicate a misunderstanding as to how unchecked exceptions are handled.
			If is felt that a RuntimeException is so prevalent that it should be declared, it 
			is probably a better idea to prevent the occurance in code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CE_CLASS_ENVY">
		<ShortDescription>Method excessively uses methods of another class</ShortDescription>
		<LongDescription>Method {1} excessively uses methods of another class</LongDescription>
		<Details>
			<![CDATA[
			<p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em></p>
			<p>This method makes extensive use of methods from another class over methods of it's own
			class. Typically this means that the functionality that is accomplished by this method
			most likely belongs with the class that is being used so liberally. Consider refactoring this
			method to be contained in that class, and to accept all the parameters needed in the method signature.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSC_LITERAL_STRING_COMPARISON">
		<ShortDescription>Method makes literal string comparisons passing the literal as an argument</ShortDescription>
		<LongDescription>Method {1} makes literal string comparisons passing the literal as an argument</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the equals or compareTo methods on a String variable passing in a String literal.
			A NullPointerException may occur if the string variable is null. If instead the method was called on
			the string literal, and the variable was passed as an argument, this exception could never happen.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS">
		<ShortDescription>Constructor makes call to non-final method</ShortDescription>
		<LongDescription>Constructor {1} makes call to non-final method</LongDescription>
		<Details>
			<![CDATA[
			<p>This constructor makes a call to a non-final method. Since this method can be overriden, a subclasses
			implementation will be executing against an object that has not been initialized at the subclass level.
			You should mark all methods called from the constructor as final to avoid this problem.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DLC_DUBIOUS_LIST_COLLECTION">
		<ShortDescription>Class defines List based fields but uses them like Sets</ShortDescription>
		<LongDescription>Class {0} defines List based fields but uses them like Sets</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines a field based on java.util.List, but uses it to some extent like a Set. Since
			lookup type operations are performed using a linear search for Lists, the performance for large
			Lists will be poor. Consider changing this fields implementation to a set based one. If order of
			iteration is important to maintain insert order, perhaps consider a LinkedHashSet.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PL_PARALLEL_LISTS">
		<ShortDescription>Class defines two or more one for one associated lists or arrays</ShortDescription>
		<LongDescription>Class {0} defines two or more one for one associated lists or arrays</LongDescription>
		<Details>
			<![CDATA[
			<p>This class appears to maintain two or more lists or arrays who's contains is related one-for-one
			through the index of the list or array. Consider creating a separate class to hold all the related 
			pieces of information, and adding instances of this class to just one list or array, or if just two values, use
			a Map to associate one value with the other.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FP_FINAL_PARAMETERS">
		<ShortDescription>Method does not define a parameter as final, but could</ShortDescription>
		<LongDescription>Method {1} does not define a parameter as final, but could</LongDescription>
		<Details>
			<![CDATA[
			<p>This method correctly does not write to a parameter. To help document this, and to perhaps
			help the jvm optimize the invocation of this method, you should consider defining these parameters
			as final.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ACEM_ABSTRACT_CLASS_EMPTY_METHODS">
		<ShortDescription>Empty method could be declared abstract</ShortDescription>
		<LongDescription>Empty method {1} could be declared abstract</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is empty or merely throws an exception. Since the class it is defined in is 
			abstract, it may be more correct to define this method as abstract instead, so that proper
			subclass behavior is enforced.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MAC_MANUAL_ARRAY_COPY">
		<ShortDescription>Method copies arrays manually</ShortDescription>
		<LongDescription>Method {1} copies arrays manually</LongDescription>
		<Details>
			<![CDATA[
			<p>This method copies data from one array to another manually using a loop.
			It is much better performing to use System.arraycopy as this method is native.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FPL_FLOATING_POINT_LOOPS">
		<ShortDescription>Method uses floating point indexed loops</ShortDescription>
		<LongDescription>Method {1} uses floating point indexed loops</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses floating point variables to index a loop. Since floating point
			math is imprecise, rounding errors will accumulate over time each time the loop is
			executed. It is usually better to use integer indexing, and calculate the new value
			of the floating point number at the top of the loop body.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCMU_NON_COLLECTION_METHOD_USE">
		<ShortDescription>Method uses old non collections interface methods</ShortDescription>
		<LongDescription>Method {1} uses old non collections interface methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes calls to collection classes where the method is not defined by the Collections
			interface, and an equivalent method exists in the interface. By using the new methods,
			you can define this object by the Collections interface and allow better decoupling.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CAO_CONFUSING_AUTOBOXED_OVERLOADING">
		<ShortDescription>Class defines methods which confuse Character with int parameters</ShortDescription>
		<LongDescription>Class {0} defines methods which confuse Character with int parameters</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines two methods that differ only by a parameter being defined
			as Character vs. int, long, float or double. As autoboxing is present, it may be
			assumed that a parameter of 'a' would map to the Character version, but does not.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AFBR_ABNORMAL_FINALLY_BLOCK_RETURN">
		<ShortDescription>Class has abnormal exit from finally block</ShortDescription>
		<LongDescription>Class {0} has abnormal exit from finally block</LongDescription>
		<Details>
			<![CDATA[
			<p>This class returns or throws exceptions from a finally block. This will
			mask real program logic in the try block, and short-circuit normal method termination.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SMII_STATIC_METHOD_INSTANCE_INVOCATION">
		<ShortDescription>Method calls static method on instance reference</ShortDescription>
		<LongDescription>Method {1} calls static method on instance reference</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes a static method call on an instance reference. For
			reading comprehension of the code is better to call the method on the class,
			rather than an instance. Perhaps this method's static nature has changed since
			this code was written, and should be revisited.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="STS_SPURIOUS_THREAD_STATES">
		<ShortDescription>Method calls wait, notify or notifyAll on a Thread instance</ShortDescription>
		<LongDescription>Method {1} calls wait, notify or notifyAll on a Thread instance</LongDescription>
		<Details>
			<![CDATA[
			<p>This method invokes the methods wait, notify or notifyAll on a Thread instance.
			Doing so will confuse the internal thread state behaviour causing spurious thread
			wakeups/sleeps because the internal mechanism also uses the thread instance for it's 
			notifications.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_CTOR">
		<ShortDescription>Method passes primitive wrapper to same primitive wrapper constructor</ShortDescription>
		<LongDescription>Method {1} passes primitive wrapper to same primitive wrapper constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's constructor.
			Since wrapper classes are immutable, you can just use the original object, rather
			than constructing a new one. This code works because of an abuse of autoboxing.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_STRING_CTOR">
		<ShortDescription>Method passes parsed string to primitive wrapper constructor</ShortDescription>
		<LongDescription>Method {1} passes parsed string to primitive wrapper constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a primitive value retrieved from a BoxedPrimitive.parseBoxedPrimitive("1") call  to 
			the same class's constructor. It is simpler to just pass the string to the BoxedPrimitives constructor.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_VALUEOF">
		<ShortDescription>Method passes primitive wrapper to Wrapper class valueOf method</ShortDescription>
		<LongDescription>Method {1} passes primitive wrapper to Wrapper class valueOf method</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's .valueOf method.
			Since wrapper classes are immutable, you can just use the original object, rather
			than calling valueOf to create a new one. This code works because of an abuse of autoboxing.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_PARSE">
		<ShortDescription>Method converts String to primitive using excessive boxing</ShortDescription>
		<LongDescription>Method {1} converts String to primitive using excessive boxing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's valueOf method, which in turn calls
			the boxedValue() method to convert to a primitive. When it is desired to convert from a String
			to a primitive value, it is simpler to use the BoxedPrimitive.parseBoxedPrimitive(myString)
			method. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_VALUEOF">
		<ShortDescription>Method converts String to boxed primitive using excessive boxing</ShortDescription>
		<LongDescription>Method {1} converts String to boxed primitive using excessive boxing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's parse method, which in turn calls
			the valueOf() method to convert to a boxed primitive. When it is desired to convert from a String
			to a boxed primitive object, it is simpler to use the BoxedPrimitive.valueOf(myString)
			method. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_UNBOX">
		<ShortDescription>Method creates Boxed primitive from primitive only to get primitive value</ShortDescription>
		<LongDescription>Method {1} creates Boxed primitive from primitive only to get primitive value</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			convert it back to a primitive. Just use the primitive value instead.</p>
			<pre>
				primitive i = new BoxedPrimitive(1).primitiveValue();
					or
				primitive i = BoxedPrimitive.valueOf(1).primitiveValue();
				
					should just use 
				primitive i = 1;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_CAST">
		<ShortDescription>Method creates Boxed primitive from primitive only to cast to another primitive type</ShortDescription>
		<LongDescription>Method {1} creates Boxed primitive from primitive only to cast to another primitive type</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			cast the value to another primitive typee. It is simpler to just use casting</p>
			<pre>
				primitive i = new BoxedPrimitive(1.0).primitiveValue();
					or
				primitive i = BoxedPrimitive.valueOf(1.0).primitiveValue();
				
					should just use 
				primitive i = (primitive)1.0;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION">
		<ShortDescription>Method needlessly boxes a boolean constant</ShortDescription>
		<LongDescription>Method {1} needlessly boxes a boolean constant</LongDescription>
		<Details>
			<![CDATA[
			<p>This method assigns a Boxed boolean constant to a primitive boolean variable, or assigns a primitive boolean
			constant to a Boxed boolean variable. Use the correct constant for the variable desired. Use</p>
			<pre>
				boolean b = true;
				boolean b = false;
				
				or
				
				Boolean b = Boolean.TRUE;
				Boolean b = Boolean.FALSE;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USBR_UNNECESSARY_STORE_BEFORE_RETURN">
		<ShortDescription>Method stores return result in local before immediately returning it</ShortDescription>
		<LongDescription>Method {1} stores return result in local before immediately returning it</LongDescription>
		<Details>
			<![CDATA[
			<p>This method stores the return result in a local variable, and then immediately
			returns the local variable. It would be simpler just to return the value that is
			assigned to the local variable, directly.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="COM_COPIED_OVERRIDDEN_METHOD">
		<ShortDescription>Method is implemented with an exact copy of it's superclass's method</ShortDescription>
		<LongDescription>Method {1} is implemented with an exact copy of it's superclass's method</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is implemented using an exact copy of it's super class method's 
			implementation, which usually means that this method can just be removed.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ABC_ARRAY_BASED_COLLECTIONS">
		<ShortDescription>Method uses array as basis of collection</ShortDescription>
		<LongDescription>Method {1} uses array as basis of collection</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes an array as the key to a Map, element in a Set, or item in a List when
			the contains method is used on the List. Since arrays do not, and cannot override the equals 
			method, collection inclusion is based on the reference's address, which is probably not desired.
			In the case that this is a TreeMap or TreeSet, consider passing a Comparator to the map's
			constructor.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ODN_ORPHANED_DOM_NODE">
		<ShortDescription>Method creates DOM node but doesn't attach it to a document</ShortDescription>
		<LongDescription>Method {1} creates DOM node but doesn't attach it to a document</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a DOM node but does not attach it to a DOM document.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AOM_ABSTRACT_OVERRIDDEN_METHOD">
		<ShortDescription>Abstract method overrides a concrete implementation</ShortDescription>
		<LongDescription>Abstract method {1} overrides a concrete implementation</LongDescription>
		<Details>
			<![CDATA[
			<p>This abstract method is derived from a concrete method implementation. It is highly
			suspect that the super class method's implementation would be cast away. 
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CBX_CUSTOM_BUILT_XML">
		<ShortDescription>Method builds xml strings through adhoc concatenation</ShortDescription>
		<LongDescription>Method {1} builds xml strings through adhoc concatenation</LongDescription>
		<Details>
			<![CDATA[
			<p>This method generates an xml based string by concatenating together various 
			xml fragments, and variable values. Doing so makes the code difficult to read, modify 
			and validate. It is much more clean to built xml structures in external files that are
			read in and transformed into the final product, thru modification by Transformer.setParameter.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BSB_BLOATED_SYNCHRONIZED_BLOCK">
		<ShortDescription>Method overly synchronizes a block of code</ShortDescription>
		<LongDescription>Method {1} overly synchronizes a block of code</LongDescription>
		<Details>
			<![CDATA[
			<p>This methods implements a synchronized block, but the code found at the beginning
			of this block  only accesses local variables, and not member variables, or this. 
			To be better performance move the code that access local variables only, above the
			synchronized block, and leave the synchronized block only for field accesses, or access
			to this object.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CLI_CONSTANT_LIST_INDEX">
		<ShortDescription>Method accesses list or array with constant index</ShortDescription>
		<LongDescription>Method {1} accesses list or array with constant index</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses an array or list using a constant integer index. Often,
			this is a typo where a loop variable is intended to be used. If however, specific
			list indices mean different specific things, then perhaps replacing the list with
			a first-class object with meaningful accessors would make the code less brittle.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCR_SLOPPY_CLASS_REFLECTION">
		<ShortDescription>Method accesses statically bound class with Class.forName</ShortDescription>
		<LongDescription>Method {1} accesses statically bound class with Class.forName</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses the class object of a class that is already statically bound
			in this context, with Class.forName. Using Class.forName makes reflection more fragile
			in regards to code transformations such as obfuscation, and is unneeded here, since 
			the class in question is already 'linked' to this class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AWCBR_ARRAY_WRAPPED_CALL_BY_REFERENCE">
		<ShortDescription>Method uses 1 element array to simulate call by reference</ShortDescription>
		<LongDescription>Method {1} uses 1 element array to simulate call by reference</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a one element array to wrap an object that is to be passed to a method as an argument
			to simulate call by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SG_SLUGGISH_GUI">
		<ShortDescription>Method performs time consuming operation in gui thread</ShortDescription>
		<LongDescription>Method {1} performs time consuming operation in gui thread</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements an awt or swing listener and performs time 
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. Consider
			using a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NIR_NEEDLESS_INSTANCE_RETRIEVAL">
		<ShortDescription>Method retrieves instance to load static member</ShortDescription>
		<LongDescription>Method {1} retrieves instance to load static member</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method to load a reference to an object, and then only
			uses it to load a static member of that instance's class. It is simpler and
			better performant to just load the static field from the class itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DDC_DOUBLE_DATE_COMPARISON">
		<ShortDescription>Method uses two date comparisons when one would do</ShortDescription>
		<LongDescription>Method {1} uses two date comparisons when one would do</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares dates with two comparisons, rather than using the reverse comparison.
			So This pattern
<pre>
	if ((date1.equals( date2 )) || (date1.after( date2 )))
</pre>
			could become
<pre>
	if (date1.compareTo( date2 ) >= 0)
</pre>
			and
<pre>
	if ((date1.equals( date2 )) || (date1.before( date2 )))
</pre>
			could become
<pre>
	if (date1.compareTo( date2 ) <= 0)
</pre>
			and
<pre>
	if ((date1.before( date2 )) || (date1.after( date2 )))
</pre>
			could become
<pre>
	if (!date1.equals( date2 ))
</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SWCO_SUSPICIOUS_WAIT_ON_CONCURRENT_OBJECT">
		<ShortDescription>Method calls wait when await was probably intended</ShortDescription>
		<LongDescription>Method {1} calls wait when await was probably intended</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls wait() on a on mutex defined in the java.util.concurrent package.
			These classes, define await, instead of wait, and it is most likely that await
			was intended.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JVR_JDBC_VENDOR_RELIANCE">
		<ShortDescription>Method uses jdbc vendor specific classes and methods</ShortDescription>
		<LongDescription>Method {1} uses jdbc vendor specific classes and methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses jdbc vendor specific classes and method to perform database work.
			This makes the code specific to this vendor, and unable to run on other databases.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PMB_POSSIBLE_MEMORY_BLOAT">
		<ShortDescription>Class defines static field that appears to allow memory bloat</ShortDescription>
		<LongDescription>Class {0} defines static field that appears to allow memory bloat</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines static fields that are collections or StringBuffers that do not
			appear to have any way to clear or reduce their size. This is a potential cause of 
			memory bloat.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSYC_LOCAL_SYNCHRONIZED_COLLECTION">
		<ShortDescription>Method creates local variable-based synchronized collection</ShortDescription>
		<LongDescription>Method {1} creates local variable-based synchronized collection</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a synchronized collection and store the reference to it
			in a local variable. As local variables are by definition threadsafe, it seems
			questionable that this collection needs to be synchronized.</p>
			<p>
			<table>
				<tr><th>If you are using</th><th>consider using</th></tr>
				<tr><td>java.util.Vector</td><td>java.util.ArrayList</td></tr>
				<tr><td>java.util.Hashtable</td><td>java.util.HashMap</td></tr>
				<tr><td>java.lang.StringBuffer</td><td>java.lang.StringBuilder</td></tr>
			</table>
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FCBL_FIELD_COULD_BE_LOCAL">
		<ShortDescription>Class defines fields that are used only as locals</ShortDescription>
		<LongDescription>Class {0} defines fields that are used only as locals</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines fields that are used in a locals only fashion, 
			specifically private fields or protected fields in final classes that are accessed 
			first in each method with a store vs. a load. This field could be replaced by one
			or more local variables.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NOS_NON_OWNED_SYNCHRONIZATION">
		<ShortDescription>Class uses non owned variables to synchronize on</ShortDescription>
		<LongDescription>Class {0} uses non owned variables to synchronize on</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a synchronize block where the object that is being synchronized on,
			is not owned by this current instance. This means that other instances may use this same
			object for synchronization for its own purposes causing synchronization confusion. It is 
			always cleaner and safer to only synchronize on private fields of this class. Note that 'this'
			is not owned by the current instance, but is owned by whomever assigns it to a field of its 
			class. Synchronizing on 'this' is also not a good idea.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NRTL_NON_RECYCLEABLE_TAG_LIB">
		<ShortDescription>Tag library is not recycleable</ShortDescription>
		<LongDescription>Tag library {0} is not recycleable</LongDescription>
		<Details>
			<![CDATA[
				<p>This Tag library class implements an attribute who's associated backing store field
				is modified at another point in the tag library. In order for a taglibrary to be
				recycleable, only the container is allowed to change this attribute, through the use
				of the setXXX method of the taglib. By modifying the value programmatically, the 
				container will not initialize the attribute correctly on reuse.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NULL_LAYOUT">
		<ShortDescription>Gui uses absolute layout</ShortDescription>
		<LongDescription>Gui {0} uses absolute layout</LongDescription>
		<Details>
			<![CDATA[
				<p>This class passes null to setLayout, which specifies that components are
				to be laid out using absolute coordinates. This makes making changes for
				font sizes, etc, difficult as items will not reposition
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETLABELFOR">
		<ShortDescription>JLabel doesn't specify what it's labeling</ShortDescription>
		<LongDescription>JLabel in method {1} doesn't specify what it's labeling</LongDescription>
		<Details>
			<![CDATA[
				<p>This class uses JLabels that do not specify what fields are being labeled.
				This hampers screen readers from given appropriate feed back to users. Use
				the JLabel.setLabelFor method to accomplish this.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETSIZE">
		<ShortDescription>Window sets size manually, and doesn't use pack</ShortDescription>
		<LongDescription>Window {0} sets size manually, and doesn't use pack</LongDescription>
		<Details>
			<![CDATA[
				<p>This class creates a window, and sizes the window using setSize. It is better
				to handle font size changes to use the pack method.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NON_ACCESSIBLE_JCOMPONENT">
		<ShortDescription>Class extends JComponent but does not implement Accessible interface</ShortDescription>
		<LongDescription>Class {0} extends JComponent but does not implement Accessible interface</LongDescription>
		<Details>
			<![CDATA[
				<p>This class extends the JComponent gui control but does not implement the Accessibility interface.
				This makes this control unable to be processed by screen readers, etc, for people with reading/vision
				difficulties</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_SET_COMP_COLOR">
		<ShortDescription>Method explicitly sets the color of a Component</ShortDescription>
		<LongDescription>Method {1} Method explicitly sets the color of a Component</LongDescription>
		<Details>
			<![CDATA[
				<p>This method sets a Components explicitly foreground or background color which may
				cause difficulty with people with vision problems from using this application.
				Colors should be allowed to be set from the operating system.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NON_TRANSLATABLE_STRING">
		<ShortDescription>Method passes constant string to title/label of component</ShortDescription>
		<LongDescription>Method {1} passes constant string to title/label of component</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates a component and passes a string literal to the title or label
				of the component. As this string will be shown to users, it should be internationalizable
				through the use of a resource bundle.</p>
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="S508C_APPENDED_STRING">
		<ShortDescription>Method passes appended string to title/label of component</ShortDescription>
		<LongDescription>Method {1} passes appended string to title/label of component</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates a component and passes a string that was build up from a number of
				strings through appending multiple strings together. As foreign languages may order phrases
				differently, this will make translations difficult.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UEC_USE_ENUM_COLLECTIONS">
		<ShortDescription>Class uses an ordinary set or map with an enum class as the key</ShortDescription>
		<LongDescription>Class {0} uses an ordinary set or map with an enum class as the key</LongDescription>
		<Details>
			<![CDATA[
				<p>This class uses an ordinary set or map collection and uses an enum class as the key type.
				It is better performant to use the jdk 1.5 EnumSet or EnumMap classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SIL_SQL_IN_LOOP">
		<ShortDescription>Method executes sql queries inside of loops</ShortDescription>
		<LongDescription>Method {1} executes sql queries inside of loops</LongDescription>
		<Details>
			<![CDATA[
				<p>This method executes sql queries inside of a loop. This pattern is often inefficient
				as the number of queries may mushroom in fencepost cases. It is probably more performant
				to loop over the input and collect the key data needed for the query for all items, and
				issue one query using an in clause, or similar construct, and then loop over this result
				set, and fetch all the data at once.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NMCS_NEEDLESS_MEMBER_COLLECTION_SYNCHRONIZATION">
		<ShortDescription>Class defines unneeded synchronization on member collection</ShortDescription>
		<LongDescription>Class {0} defines unneeded synchronization on member collection</LongDescription>
		<Details>
			<![CDATA[
				<p>This class defines a private collection member as synchronized. It appears however
				that this collection isn't only modified in a static initializer, or constructor. As these
				two areas are guaranteed to be thread safe, defining this collection as synchronized is
				unnecessary and a potential performance bottleneck.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ITC_INHERITANCE_TYPE_CHECKING">
		<ShortDescription>Method uses instanceof on multiple types to arbitrate logic</ShortDescription>
		<LongDescription>Method {1} uses instanceof on multiple types to arbitrate logic</LongDescription>
		<Details>
			<![CDATA[
				<p>This method uses the instanceof operator in a series of if/else statements to 
				differentiate blocks of code based on type. If these types are related by inheritance,
				it is cleaner to just define a method in the base class, and use overridden methods
				in these classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SACM_STATIC_ARRAY_CREATED_IN_METHOD">
		<ShortDescription>Method creates array using constants</ShortDescription>
		<LongDescription>Method {1} creates array using constants</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates an array initialized by constants. Each time this method is called
				this array will be recreated. It would be more performant to define the array as a
				static field of the class instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS">
		<ShortDescription>Method appears to call the same method on the same object redundantly</ShortDescription>
		<LongDescription>Method {1} appears to call the same method on the same object redundantly</LongDescription>
		<Details>
			<![CDATA[
				<p>This method makes two consecutive calls to the same method using the same constant
				parameters, on the same instance without any intervening changes to the objects. If this
				method does not make changes to the object, which it appears it doesn't, then making
				two calls is just a waste. These method calls could be combined by assigning the
				result into a temporary, and using the temporary the second time.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UTA_USE_TO_ARRAY">
		<ShortDescription>Method manually creates array from collection</ShortDescription>
		<LongDescription>Method {1} manually creates array from collection</LongDescription>
		<Details>
			<![CDATA[
				<p>This method manually loops over a collection, pulling each element out and storing
				it in an array to build an array from the collection. It is easier, and clearer to use
				the built in collections method toArray. Given a collection 'mycollection' of type T, use
				mycollection.toArray(new T[mycollection.size()]);
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LEST_LOST_EXCEPTION_STACK_TRACE">
		<ShortDescription>Method throws alternative exception from catch block without history</ShortDescription>
		<LongDescription>Method {1} throws alternative exception from catch block without history</LongDescription>
		<Details>
			<![CDATA[
				<p>This method catches an exception, and throws a different exception, without incorporating the 
				original exception. Doing so hides the original source of the exception making debugging and fixing
				these problems difficult. It is better to use the constructor of this new exception that takes an 
				original exception so that this detail can be passed along to the user.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCPM_USE_CHARACTER_PARAMETERIZED_METHOD">
		<ShortDescription>Method passes constant String of length 1 to character overridden method</ShortDescription>
		<LongDescription>Method {1} passes constant String of length 1 to character overridden method</LongDescription>
		<Details>
			<![CDATA[
				<p>This method passes a constant literal String of length 1 as a parameter to a method, that
				exposes a similar method that takes a character. It is simpler and more expedient to handle one
				character, rather than pass a string.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="TR_TAIL_RECURSION">
		<ShortDescription>Method employs tail recursion</ShortDescription>
		<LongDescription>Method {1} employs tail recursion</LongDescription>
		<Details>
			<![CDATA[
				<p>This method recursively calls itself as the last statement of the method
				(Tail Recursion). This method can be easily refactored into a simple loop, which 
				will make it more performant, and reduce the stack size requirements.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_UNRELATED_RETURN_VALUES">
		<ShortDescription>Method returns different types of unrelated Objects</ShortDescription>
		<LongDescription>Method {1} returns different types of unrelated Objects</LongDescription>
		<Details>
			<![CDATA[
				<p>This method returns two or more unrelated types of objects (Related only through java.lang.Object).
				This will be very confusing to the code that must call it.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_CHANGE_RETURN_TYPE">
		<ShortDescription>Method returns more specific type of object than declared</ShortDescription>
		<LongDescription>Method {1} returns more specific type of object than declared</LongDescription>
		<Details>
			<![CDATA[
				<p>This method is defined to return a java.lang.Object. However, the return types
				returned from this method can be defined by a more specific class or interface. Since this
				method is not derived from a superclass or interface, it would be more clear to 
				change the return type of this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_INHERITED_METHOD_WITH_RELATED_TYPES">
		<ShortDescription>Inherited method returns more specific type of object than declared</ShortDescription>
		<LongDescription>Inherited method {1} returns more specific type of object than declared</LongDescription>
		<Details>
			<![CDATA[
				<p>This inherited method is defined to return a java.lang.Object. However, the return types returned
				from this method can be defined by a more specific class or interface. If possible consider changing the
				return type in the inheritance hierarchy of this method, otherwise the caller of this method will be brittle
				in handling of the return type.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PIS_POSSIBLE_INCOMPLETE_SERIALIZATION">
		<ShortDescription>Class doesn't serialize superclass fields</ShortDescription>
		<LongDescription>Class {0} doesn't serialize superclass fields</LongDescription>
		<Details>
			<![CDATA[
				<p>This method implements Serializable but is derived from a 
				class that does not. The super class has fields that are not serialized
				because this class does not take the responsibility of writing these fields out
				either using Serializable's writeObject method, or Externalizable's writeExternal 
				method. Therefore when this class is read from a stream, the superclass fields
				will only be initialized to the values specified in it's default constructor.
				If possible, change the superclass to implement Serializable, or implement 
				Serializable or Externalizable methods in the child class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SC_SUSPICIOUS_COMPARATOR_RETURN_VALUES">
		<ShortDescription>Comparator method doesn't seem to return all ordering values</ShortDescription>
		<LongDescription>Comparator method {1} doesn't seem to return all ordering values</LongDescription>
		<Details>
			<![CDATA[
				<p>This compareTo or compare method returns constant values for to represent less than,
				equals and greater than. However it does not return each type. Given that comparators 
				are transitive, this seems incorrect.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NEGATIVE_BITSET_ITEM">
		<ShortDescription>Method passes a negative number as a bit to a BitSet which isn't supported</ShortDescription>
		<LongDescription>Method {1} passes a negative number as a bit to a BitSet which isn't supported</LongDescription>
		<Details>
			<![CDATA[
				<p>This method passes a constant negative value as a bit position to a java.util.BitSet. The BitSet class
				doesn't support negative values, and thus this method call will not work as expected.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INTERN_ON_CONSTANT">
		<ShortDescription>Method calls intern on a string constant</ShortDescription>
		<LongDescription>Method {1} calls intern on a string constant</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls intern on a constant string. As constant strings are already interned, this call
				is superfluous</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NO_CHAR_SB_CTOR">
		<ShortDescription>Method appears to pass character to StringBuffer or StringBuilder integer constructor</ShortDescription>
		<LongDescription>Method {1} appears to pass character to StringBuffer or StringBuilder integer constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a StringBuffer or a StringBuilder using the constructor that takes an integer, but
			appears to pass a character instead. It is probable that the author assumed that character would be appended to the
			StringBuffer/Builder, but instead the integer value of the character is used as an initial size for the buffer.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_MATH_CONSTANT">
		<ShortDescription>Method uses non standard math constant</ShortDescription>
		<LongDescription>Method {1} uses non standard math constant</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines its own version of <em>PI</em> or <em>e</em> and the value is not as precise as the
			one defined in the constants Math.PI or Math.E. Use these constants instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STUTTERED_ASSIGNMENT">
		<ShortDescription>Method assigns a value to a local twice in a row</ShortDescription>
		<LongDescription>Method {1} assigns a value to a local twice in a row</LongDescription>
		<Details>
			<![CDATA[
			<p>This method assigns a value twice in a row in a stuttered way such as
			<code>a = a = 5;</code> This is most probably a cut and paste error where the duplicate
			assignment can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_ISNAN">
		<ShortDescription>Method compares a double to Double.NAN</ShortDescription>
		<LongDescription>Method {1} compares a double to Double.NAN</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares a douhle or float to the constant Double.NaN or Float.NaN. You should use
			Double.isNaN(d) or Float.isNaN(f) if a primitive; or d.isNaN() or f.isNaN() if a boxed double, instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_BIGDECIMAL_STRING_CTOR">
		<ShortDescription>Method passes double value to BigDecimal Constructor</ShortDescription>
		<LongDescription>Method {1} passes double value to BigDecimal Constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the BigDecimal constructor that takes a double, and passes a literal double constant value. Since 
			the use of BigDecimal is to get better precision than double, by passing a double, you only get the precision of double number
			space. To take advantage of the BigDecimal space, pass the number as a string. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STRINGBUFFER_WITH_EMPTY_STRING">
		<ShortDescription>Method passes empty string to StringBuffer of StringBuilder constructor</ShortDescription>
		<LongDescription>Method {1} passes empty string to StringBuffer of StringBuilder constructor</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the StringBuffer of StringBuilder constructor passing in a constant empty string (""). 
				This is the same as calling the default constructor, but makes the code work harder. Consider passing in a
				default size instead.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_EQUALS_ON_ENUM">
		<ShortDescription>Method calls equals on an enum instance</ShortDescription>
		<LongDescription>Method {1} calls equals on an enum instance</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the equals(Object) method on an enum instance. Since enums values are singletons,
				you can use == to safely compare two enum values. In fact, the implementation for Enum.equals does just
				that.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INVALID_BOOLEAN_NULL_CHECK">
		<ShortDescription>Method uses invalid C++ style null check on Boolean</ShortDescription>
		<LongDescription>Method {1} uses invalid C++ style null check on Boolean</LongDescription>
		<Details>
			<![CDATA[
				<p>This method attempts to check for null by just refering to the variable name
				as would be done in C++. This ordinarily would be considered a compile error, except the
				variable in question is a Boolean, which does an auto unbox to boolean.</p>
				<pre>
				if (b && b.booleanValue())
				should be
				if ((b != null) && b.booleanValue())
				</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_CHARAT">
		<ShortDescription>Method fetches character array just to do the equivalent of the charAt method</ShortDescription>
		<LongDescription>Method {1} fetches character array just to do the equivalent of the charAt method</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the toCharArray method on a String the fetch an array of characters, only
				to retrieve one of those characters by index. It is more performant to just use the charAt method.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USELESS_TRINARY">
		<ShortDescription>Method uses a trinary operator to cast a boolean to true or false</ShortDescription>
		<LongDescription>Method {1} uses a trinary operator to cast a boolean to true or false</LongDescription>
		<Details>
			<![CDATA[
				<p>This method tests the value of a boolean and using a trinary operator to return either true or false.
				The trinary operator is completely unecessary, just use the original boolean value.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_SUSPECT_STRING_TEST">
		<ShortDescription>Method treats null and normal strings differently than an empty strings</ShortDescription>
		<LongDescription>Method {1} treats null and normal strings differently than an empty strings</LongDescription>
		<Details>
			<![CDATA[
				<p>This method tests a string, and groups null values with real strings, leaving empty strings as another
				case. This might be perfectly valid, but normally, null strings and empty strings are logically handled the same way, 
				and so this test may be flawed.</p>
				<p>Pattern found is one of the following
				<pre>if ((s == null) || (s.length() > 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
				<pre>if ((s == null) || (s.length() != 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
				<pre>if ((s != null) && (s.length() == 0))</pre> -- did you mean ((s != null) && (s.length() > 0))?
				or perhaps ((s == null) || (s.length() == 0))?
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_STRINGBUILDER_LENGTH">
		<ShortDescription>Method converts StringBuffer or Builder to String just to get it's length</ShortDescription>
		<LongDescription>Method {1} converts StringBuffer or Builder to String just to get it's length</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the toString method on a StringBuffer or StringBuilder only to call length() on the resulting
				string. It is faster, and less memory intensive to just call the length method directly on the StringBuffer or StringBuilder
				itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INVALID_CALENDAR_COMPARE">
		<ShortDescription>Method passes a non calendar object to Calendar.before or Calendar.after</ShortDescription>
		<LongDescription>Method {1} passes a non calendar object to Calendar.before or Calendar.after</LongDescription>
		<Details>
			<![CDATA[
				<p>This method passes a non calendar object to the java.util.Calendar.after or java.util.Calendar.before methods.
				Even though these methods take an Object as a parameter type, only Calendar type objects are supported, otherwise
				false is returned</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_CONTAINSKEY">
		<ShortDescription>Method calls keySet() just to call contains, use containsKey instead</ShortDescription>
		<LongDescription>Method {1} calls keySet() just to call contains, use containsKey instead</LongDescription>
		<Details>	
			<![CDATA[
				<p>This method calls mySet.keySet().contains("foo") when mySet.containsKey("foo") is simpler</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_ISEMPTY">
		<ShortDescription>Method checks the size of a collection against zero rather than using isEmpty()</ShortDescription>
		<LongDescription>Method {1} checks the size of a collection against zero rather than using isEmpty()</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the size() method on a collection and compares the result to zero to see if the collection
				is empty. For better code clarity, it is better to just use col.isEmpty() or !col.isEmpty()</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_GETPROPERTY">
		<ShortDescription>Method calls getProperties just to get one property, use getProperty instead</ShortDescription>
		<LongDescription>Method {1} calls getProperties just to get one property, use getProperty instead</LongDescription>
		<Details>
			<![CDATA[
				<table>
					<tr><td>This method uses</td></tr>
					<tr><td>String prop = System.getProperties().getProperty("foo");</td></tr
					<tr><td>instead of simply using</td></tr>
					<tr><td>String prop = System.getProperty("foo");</td></tr>
				</table>
			]]>	
		</Details>
	</BugPattern>

	<BugPattern type="SPP_SERIALVER_SHOULD_BE_PRIVATE">
		<ShortDescription>Class defines a serialVersionUID as non private</ShortDescription>
		<LongDescription>Class {0} defines a serialVersionUID as non private</LongDescription>
		<Details>
			<![CDATA[
				This class defines a static field 'serialVersionUID' to define the serialization
				version for this class. This field is marked as non private. As the serialVersionUID only
				controls the current class, and doesn't effect any derived classes, defining it as non
				private is confusing. It is suggested you change this variable to be private.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USELESS_CASING">
		<ShortDescription>Method compares string without case after enforcing a case</ShortDescription>
		<LongDescription>Method {1} compares string without case after enforcing a case</LongDescription>
		<Details>
			<![CDATA[
				This method compares two strings with compareToIgnoreCase or equalsIgnoreCase, after having
				called toUpperCase or toLowerCase on the string in question. As you are comparing with out
				concern to case, the toUpperCase or toLowerCase calls are pointless and can be removed.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NON_ARRAY_PARM">
		<ShortDescription>Method passes a non array object to a parameter that expects an array</ShortDescription>
		<LongDescription>Method {1} passes a non array object to a parameter that expects an array</LongDescription>
		<Details>
			<![CDATA[
				This method expects an array to be passed as one of its parameters, but unfortunately defines
				the parameter as Object. This invocation of this method does not pass an array and will throw
				an exception when run.
			]]>
		</Details>
	</BugPattern>
	
		<BugPattern type="SPP_EMPTY_CASING">
		<ShortDescription>Method passes an empty string to equalsIgnoreCase or compareToIgnoreCase</ShortDescription>
		<LongDescription>Method {1} passes an empty string to equalsIgnoreCase or compareToIgnoreCase</LongDescription>
		<Details>
			<![CDATA[
				This method passes the empty string "" to equalsIgnoreCase or compareToIgnoreCase, as the empty string
				is not case sensitive using equals is simpler. It would be even simpler to do a length() == 0 test.
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="SPP_TEMPORARY_TRIM">
		<ShortDescription>Method trims a String temporarily</ShortDescription>
		<LongDescription>Method {1} trims a String temporarily</LongDescription>
		<Details>
			<![CDATA[
				This method calls trim() on a String without assigning the new string to another variable.
				It then calls length() or equals on this trimmed string. If trimming the string was important
				for determining it's length of it's equality, it should be trimmed when you actually go to use it.
				It would make more sense to first trim the String, store the trimmed value in a variable, and then
				continue to test and use that trimmed string.
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="SPP_STRINGBUILDER_IS_MUTABLE">
        <ShortDescription>Method needlessly assigns a StringBuilder to itself, as it's mutable</ShortDescription>
        <LongDescription>Method {1} needlessly assigns a StringBuilder to itself, as it's mutable</LongDescription>
        <Details>
            <![CDATA[
                This method calls StringBuilder.append and assigns the results to the same StringBuilder as
                <pre>sb = sb.append("foo")</pre>
                As StringBuilder is mutable this is not necessary.
                This is also true of StringBuffer.
            ]]>
        </Details>
    </BugPattern>
	
	<BugPattern type="BAS_BLOATED_ASSIGNMENT_SCOPE">
		<ShortDescription>Method assigns a variable in a larger scope then is needed</ShortDescription>
		<LongDescription>Method {1} assigns a variable in a larger scope then is needed</LongDescription>
		<Details>
			<![CDATA[
			<p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em>
			This method assigns a value to a variable in an outer scope compared to where the variable is actually used. 
			Assuming this evaluation does not have side effects, the assignment can be moved into the inner scope (if block)
			so that its execution time isn't taken up if the if guard is false. Care should be
			taken however that the right hand side of the assignment does not contain side 
			effects that are required to happen, or that changes are not made further down that
			will effect the execution of the assignment when done later on.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCII_SPOILED_CHILD_INTERFACE_IMPLEMENTOR">
		<ShortDescription>Class implements interface by relying on unknowing superclass methods</ShortDescription>
		<LongDescription>Class {0} implements interface by relying on unknowing superclass methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This class declares that it implements an interface, but does so by relying on methods supplied
			by superclasses, even though those superclasses know nothing about the interface in question. If you wish
			to have the child not implement all the methods of the interface, it would probably be better to declare
			the superclass as implementing the interface, and if that class does not provide all the methods, then declare
			that superclass abstract.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_DELETING_WHILE_ITERATING">
		<ShortDescription>Method deletes collection element while iterating</ShortDescription>
		<LongDescription>Method {1} deletes collection element while iterating</LongDescription>
		<Details>
			<![CDATA[
			<p>This method removes items from a collection using the remove method of the collection, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown. To avoid this, the remove 
			method of the iterator should be used.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_MODIFYING_WHILE_ITERATING">
		<ShortDescription>Method modifies collection element while iterating</ShortDescription>
		<LongDescription>Method {1} modifies collection element while iterating</LongDescription>
		<Details>
			<![CDATA[
			<p>This method modifies the contents of a collection using the collection api methods, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USS_USE_STRING_SPLIT">
		<ShortDescription>Method builds String array using String Tokenizing</ShortDescription>
		<LongDescription>Method {1} builds String array using String Tokenizing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a StringTokenizer to split up a String and then walks thru the
			separated elements and builds an array from these enumerated values. It is simpler 
			and easier to use the String.split method.</p>
			<p>PLEASE NOTE: String.split will return an array of 1 element when passed the 
			empty string, as opposed to using StringTokenizer which returns false on the first
			hasMoreElements/hasMoreTokens call. So you may need to use</p>
			<pre>
				if (s.length() > 0)
					return s.split(";");
				return new String[0];
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SJVU_SUSPICIOUS_JDK_VERSION_USE">
		<ShortDescription>Method uses rt.jar class or method that does not exist</ShortDescription>
		<LongDescription>Method {1} uses rt.jar class or method that does not exist for the version the class is compiled for</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method that does not exist, on a class that does not exist in the jdk that
			this class has been compiled for. This can happen if you compile the class specifying the -source and
			-target options, and use a version that is before the version of the compiler's JDK.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UAA_USE_ADD_ALL">
		<ShortDescription>Method uses simple loop to copy contents of one collection to another</ShortDescription>
		<LongDescription>Method {1} uses simple loop to copy contents of one collection to another</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a simple for loop to copy the contents of a set, list, map key/value, array or other collection
			to another collection. It is simpler and more straight forward to just call the addAll method of the destination collection
			passing in the source collection. In the case that the source is an array, you can use Array.asList method to massage the array
			into a collection</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MRC_METHOD_RETURNS_CONSTANT">
		<ShortDescription>Private method only returns one constant value</ShortDescription>
		<LongDescription>Private method {1} only returns one constant value</LongDescription>
		<Details>
			<![CDATA[
			<p>This private or static method only returns one constant value. As this method is private or static,
			it's behavior can't be overridden, and thus the return of a constant value seems dubious.
			Either the method should be changed to return no value, or perhaps another return value
			was expected to be returned in another code path in this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCS_NEEDLESS_CUSTOM_SERIALIZATION">
		<ShortDescription>Method needlessly implements what is default streaming behavior</ShortDescription>
		<LongDescription>Method {1} needlessly implements what is default streaming behavior</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements the Serializable interface by performing the same operations that
			would be done if this method did not exist. Since this is the case, this method is not needed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MOM_MISLEADING_OVERLOAD_MODEL">
		<ShortDescription>Class 'overloads' a method with both instance and static versions</ShortDescription>
		<LongDescription>Class {0} 'overloads' a method with both instance and static versions</LongDescription>
		<Details>
			<![CDATA[
			<p>This class 'overloads' the same method with both an instance and static version. As the use
			of these two models is different, it will be confusing to the users of these methods.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS">
		<ShortDescription>Unconstrained method converts checked exception to unchecked</ShortDescription>
		<LongDescription>Unconstrained method {1} converts checked exception to unchecked</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is not constrained by an interface or superclass, but converts a caught checked exception
			to unchecked exception and thrown. It would be more appropriate just throw the checked exception, adding
			the exception to the throws clause of the method.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_HAS_CHECKED">
		<ShortDescription>Constrained method converts checked exception to unchecked instead of another allowable checked exception</ShortDescription>
		<LongDescription>Constrained method {1} converts checked exception to unchecked instead of another allowable checked exception</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface of super class to not throw a 
			checked exception that was caught. Therefore this exception was converted to an unchecked exception and 
			thrown. It would probably be better to throw the closest checked exception allowed, and to annotate
			the new exception with the original exception using the initial cause field.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CHECKED">
		<ShortDescription>Constrained method converts checked exception to unchecked</ShortDescription>
		<LongDescription>Constrained method {1} converts checked exception to unchecked</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface or super class to not throw
			any checked exceptions. Therefore a caught checked exception was converted to an unchecked exception
			and thrown. However it appears that the class in question is owned by the same author as the constraining
			interface or superclass. Consider changes the signature of this method to include the checked exception.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CFS_CONFUSING_FUNCTION_SEMANTICS">
		<ShortDescription>Method returns modified parameter</ShortDescription>
		<LongDescription>Method {1} returns modified parameter</LongDescription>
		<Details>
			<![CDATA[
			<p>This method appears to modify a parameter, and then return this parameter as the 
			methods return value. This will be confusing to callers of this method, as it won't be
			apparent that the 'original' passed in parameter will be changed as well. If the purpose
			of this method is to change the parameter, it would be more clear to change the method to 
			a have a void return value. If a return type is required due to interface or superclass contract,
			perhaps a clone of the parameter should be made.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
		<ShortDescription>Method passes constant to second (actual) assertion parameter</ShortDescription>
		<LongDescription>Method {1} passes constant to second (actual) assertion parameter</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls assert passing a constant value as the second of the two values. The assert
			method assumes that the expected value is the first parameter, and so it appears that the order
			of values has been swapped here.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_INEXACT_DOUBLE">
		<ShortDescription>Method asserts that two doubles are exactly equal</ShortDescription>
		<LongDescription>Method {1} asserts that two doubles are exactly equal</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls assert with two doubles or Doubles. Due to the inprecision of doubles, you
			should be using the assert method that takes a range parameter that gives a range of error.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
		<ShortDescription>Method asserts that a value is true or false</ShortDescription>
		<LongDescription>Method {1} asserts that a value is true or false</LongDescription>
		<Details>
			<![CDATA[
			<p>This method asserts that a value is equal to true or false. It is simpler to just 
			use assertTrue, or assertFalse, instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
		<ShortDescription>Method asserts that an auto-boxed value is not null</ShortDescription>
		<LongDescription>Method {1} asserts that an auto-boxed value is not null</LongDescription>
		<Details>
			<![CDATA[
			<p>This method asserts that a primitive value that was autoboxed into a boxed primitive was not 
			null. This will never happen, as primitives are never null, and thus the autoboxed value isn't 
			either.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCA_SUSPICIOUS_CLONE_ALGORITHM">
		<ShortDescription>Clone method stores a new value to member field of source object</ShortDescription>
		<LongDescription>Clone method {1} stores a new value to member field of source object</LongDescription>
		<Details>
			<![CDATA[
			<p>The clone method stores a value to a member field of the source object. Normally, all 
			changes are made to the cloned object, and given that cloning is almost always considered
			a read-only operation, this seems incorrect.</p>]]>
		</Details>
	</BugPattern>

	<BugPattern type="WEM_WEAK_EXCEPTION_MESSAGING">
		<ShortDescription>Method throws exception with static message string</ShortDescription>
		<LongDescription>Method {1} throws exception with static message string</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates and throws an exception using a static string as the exceptions message.
			Without any specific context of this particular exception invocation, such as the value of parameters, 
			key member variables, or local variables, it may be difficult to infer how this exception occurred. Consider
			adding context to the exception message.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCSS_SUSPICIOUS_CLUSTERED_SESSION_SUPPORT">
		<ShortDescription>Method modifies http session attribute without calling setAttribute</ShortDescription>
		<LongDescription>Method {1} modifies http session attribute without calling setAttribute</LongDescription>
		<Details>
			<![CDATA[
			<p>This method fetches a complex object from an HttpSession object, modifies this object, but does
			not call setAttribute, to inform the application server that this attribute has been changed. This will
			cause this attribute not to be updated in other servers in a clustered environment, as only changes marked
			by a call to setAttribute are replicated.</p>
			]]>
		</Details>
	</BugPattern>

   <BugPattern type="LO_LOGGER_LOST_EXCEPTION_STACK_TRACE">
      <ShortDescription>Method incorrectly passes exception as first argument to logger method</ShortDescription>
      <LongDescription>Method {1} incorrectly passes exception as first argument to logger method</LongDescription>
      <Details>
         <![CDATA[
         <p>This method passes an exception as the first argument to a logger method. The stack
         trace is potentially lost due to the logger emitting the exception using toString(). It
         is better to construct a log message with sufficient context and pass the exception as
         the second argument to capture the stack trace.</p>
         ]]>
      </Details>
   </BugPattern>

	<BugPattern type="LO_SUSPECT_LOG_CLASS">
		<ShortDescription>Method specifies an unrelated class when allocating a Logger</ShortDescription>
		<LongDescription>Method {1} specifies an unrelated class when allocating a Logger</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a Logger by passing in a specification for a class that is unrelated
			to the class in which the logger is going to be used. This is likely caused by copy/paste code.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_SUSPECT_LOG_PARAMETER">
		<ShortDescription>Constructor declares a Logger parameter</ShortDescription>
		<LongDescription>Constructor {1} declares a Logger parameter</LongDescription>
		<Details>
			<![CDATA[
			<p>This constructor declares a parameter that is a Logger. As loggers are meant to be
			created statically per class, it doesn't make sense that you would pass a Logger from one
			class to another. Declare the Logger static in each class instead.</p>
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="LO_STUTTERED_MESSAGE">
		<ShortDescription>Method stutters exception message in logger</ShortDescription>
		<LongDescription>Method {1} stutters exception message in logger</LongDescription>
		<Details>
			<![CDATA[
				This method uses a logger method that takes an exception, and passes the result of
				the getMessage() method on the exception that occurred as the log message.
				Since you are already passing in the exception, that message is already present in the
				logs, and by passing it in as the message, you are just stuttering information.
				It would be more helpful to provide a hand written message that describes the error in
				this method, possibly including the values of key variables.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IICU_INCORRECT_INTERNAL_CLASS_USE">
		<ShortDescription>Class relies on internal api classes</ShortDescription>
		<LongDescription>Class {0} relies on internal api classes</LongDescription>
		<Details>
			<![CDATA[
			<p>This class makes use of internal api classes. As these
			classes are not documented, nor externally released as part of the api, they are subject
			to change or removal. You should not be using these classes.</p>
			Packages that shouldn't be used are:
			<ul>
				<li>com.sun.xxx</li>
				<li>org.apache.xerces.xxx</li>
				<li>org.apache.xalan.xxx</li>
			</ul>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DSOC_DUBIOUS_SET_OF_COLLECTIONS">
		<ShortDescription>Method uses a set of collections</ShortDescription>
		<LongDescription>Method {1} uses a set of collections</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a set that contains other collections, or a Map whose keySet is
			another collection. As collections tend to calculate hashCode, equals and compareTo by 
			iterating the contents of the collection, this can perform poorly.</p>
			<p>In addition, when a set is used, you typically are using it to do 'contains', or 'find'
			type functionality, which seems dubious when done on a collection</p>
			<p>Finally, as a collection is often modified, problems will occur if the collection is 
			contained in a set, because the hashCode, equals or compareTo values will change while the
			collection is in the set</p>
			<p>If you wish to maintain a collection of collections, it is probably better to use a List
			as the outer collection</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BED_BOGUS_EXCEPTION_DECLARATION">
		<ShortDescription>Non derivable method declares throwing an exception that isn't thrown</ShortDescription>
		<LongDescription>Non derivable method {1} declares throwing an exception that isn't thrown</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares that it throws a checked exception that it does not throw. As this method is
			either a constructor, static method or private method, there is no reason for this method to declare
			the exception in its throws clause, and just causes calling methods to unnecessarily handle an exception
			that will never be thrown. The exception in question should be removed from the throws clause.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UNNC_UNNECESSARY_NEW_NULL_CHECK">
		<ShortDescription>Method checks the result of a new allocation</ShortDescription>
		<LongDescription>Method {1} checks the result of a new allocation</LongDescription>
		<Details>
			<![CDATA[
			<p>This method allocations an object with new, and then checks that the object is null
			or non null. As the new operator is guaranteed to either succeed or throw an exception,
			this null check is unnecessary and can be removed.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DTEP_DEPRECATED_TYPESAFE_ENUM_PATTERN">
		<ShortDescription>Class appears to implement the old style type safe enum pattern</ShortDescription>
		<LongDescription>Class {0} appears to implement the old style type safe enum pattern</LongDescription>
		<Details>
			<![CDATA[
			<p>This class appears to implement the old style type safe enum pattern that was used in place of
			real enums. Since this class is compiled with java 1.5 or better, it would be simpler and more 
			easy to understand if it was just switched over to an enum.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SMA_STUTTERED_METHOD_ARGUMENTS">
		<ShortDescription>Code calls a method passing the same value to two different arguments</ShortDescription>
		<LongDescription>Code {1} calls a method passing the same value to two different arguments</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method passing the same value for two or more of the parameters.
			Often this is a cut/paste bug, but if not, it is confusing why you would pass the same value for two
			different parameters. Perhaps an alternative method that just takes one parameter should be overridden
			in this case.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="TBP_TRISTATE_BOOLEAN_PATTERN">
		<ShortDescription>Method returns null for Boolean type</ShortDescription>
		<LongDescription>Method {1} returns null for Boolean type</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares that it returns a Boolean value. However the code
			can return a null value. As this is now three values that can be returned;
			Boolean.TRUE, Boolean.FALSE, null; you have changed what a Boolean means.
			It would be clearer to just create a new Enum that has the three values
			you want, and define that the method returns that type.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SUA_SUSPICIOUS_UNINITIALIZED_ARRAY">
		<ShortDescription>Method returns an array that appears not to be initialized</ShortDescription>
		<LongDescription>Method {1} returns an array that appears not to be initialized</LongDescription>
		<Details>
			<![CDATA[
			<p>This method returns an array that was allocated but apparently not initialized. It is
			possible that the caller of this method will do the work of initializing this array, but
			that is not a common pattern, and it is assumed that this array has just been forgotten to 
			be initialized.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ITU_INAPPROPRIATE_TOSTRING_USE">
		<ShortDescription>Method performs algorithmic operations on the result of a toString() call</ShortDescription>
		<LongDescription>Method {1} performs algorithmic operations on the result of a toString() call</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls algorithmic operations on a String that was returned from a toString() method.
			As these methods are for debugging/logging purposes, it shouldn't be the basis of core logic in your code.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IKNC_INCONSISTENT_HTTP_ATTRIBUTE_CASING">
		<ShortDescription>Method uses the same HttpSession attribute name but with different casing</ShortDescription>
		<LongDescription>Method {1} uses the same HttpSession attribute name but with different casing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method sets or gets an HttpSession attribute with a parmeter name that was used in other locations
			but with a different casing. As HttpSession attribute are case sensitive, this will be very confusing.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IKNC_INCONSISTENT_HTTP_PARAM_CASING">
		<ShortDescription>Method uses the same HttpRequest parameter name but with different casing</ShortDescription>
		<LongDescription>Method {1} uses the same HttpRequest parameter name but with different casing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method fetches an HttpServletRequest parameter with a parameter name that was used in other locations
			but with a different casing. As HttpServletRequest parameters are case sensitive, this will be very confusing.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="OC_OVERZEALOUS_CASTING">
		<ShortDescription>Method manually casts the right hand side of an assignment more specifically than needed</ShortDescription>
		<LongDescription>Method {1} manually casts the right hand side of an assignment more specifically than needed</LongDescription>
		<Details>
			<![CDATA[
			<p>This method casts the right hand side of an expression to a class that is more specific than the 
			variable on the left hand side of the assignment. The cast only has to be as specific as what the variable
			that is on the left. Using a more specific type on the right hand side just increases cohesion.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PDP_POORLY_DEFINED_PARAMETER">
		<ShortDescription>Method defines parameters more abstractly than needed to function properly</ShortDescription>
		<LongDescription>Method {1} defines parameters more abstractly than needed to function properly</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines parameters at a more abstract level than is actually needed to function correctly,
			as the code casts these parameters to more concrete types. Since this method is not derivable, you should 
			just define the parameters with the type that is needed.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NSE_NON_SYMMETRIC_EQUALS">
		<ShortDescription>Equals method compares this object against other types in a non symmetric way</ShortDescription>
		<LongDescription>Equals method {1} compares this object against other types in a non symmetric way</LongDescription>
		<Details>
			<![CDATA[
			<p>This class implements an equals method that compares this object against another type of object.
			This is almost always a bad thing to do, but if it is to be done, you must make sure that the basic
			symmetry rule of equivalence is maintained, that being if a equals b, then b equals a. It does not
			appear that the class that is being compared to this class knows about this class, and doesn't compare itself
			to this.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CVAA_CONTRAVARIANT_ARRAY_ASSIGNMENT">
		<ShortDescription>Method performs a contravariant array assignment</ShortDescription>
		<LongDescription>Method {1} performs a contravariant array assignment</LongDescription>
		<Details>
			<![CDATA[
			<p>This method contains a contravariant array assignment. Since arrays are mutable data structures, their use 
			must be restricted to covariant or invariant usage</p>
			
			<pre>
			class A {}
			class B extends A {}
			
			 B[] b = new B[2];
			 A[] a = b;
			</pre>         
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CVAA_CONTRAVARIANT_ELEMENT_ASSIGNMENT">
		<ShortDescription>Method performs a contravariant array element assignment</ShortDescription>
		<LongDescription>Method {1} performs a contravariant array element assignment</LongDescription>
		<Details>
			<![CDATA[
			<p>This method contains a contravariant array element assignment. Since arrays are mutable 
			data structures, their use must be restricted to covariant or invariant usage</p>
			
			<pre>
			class A {}
			class B extends A {}
			
			 B[] b = new B[2];
			 A[] a = b;
			 a[0] = new A(); // results in ArrayStoreException (Runtime)
			</pre>         
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NFF_NON_FUNCTIONAL_FIELD">
		<ShortDescription>Serializable class defines a final transient field</ShortDescription>
		<LongDescription>Serializable class {0} defines a final transient field</LongDescription>
		<Details>
			<![CDATA[
			<p>This serializable class defines a field as both transient and final. As transient fields
			are not serialized across the stream, it is required that some piece of code reinitialize that field
			when it is deserialized. But since constructors aren't called when deserialization, the field is not initialized. 
			And since the field is final, no other method can initialize it as well.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SNG_SUSPICIOUS_NULL_FIELD_GUARD">
		<ShortDescription>Method tests a field for not null as guard and reassigns it</ShortDescription>
		<LongDescription>Method {1} tests a field for not null as guard and reassigns it</LongDescription>
		<Details>
    			<![CDATA[
    			<p>This method tests a field to make sure it's not null before executing a conditional block of
    			code. However in the conditional block it reassigns the field. It is likely that the guard
    			should have been a check to see if the field is null, not that the field was not null.</p>
    			]]>
    		</Details>
	</BugPattern>

	<BugPattern type="SNG_SUSPICIOUS_NULL_LOCAL_GUARD">
		<ShortDescription>Method tests a local variable for not null as guard and reassigns it</ShortDescription>
		<LongDescription>Method {1} tests a local variable for not null as guard and reassigns it</LongDescription>
		<Details>
    			<![CDATA[
    			<p>This method tests a local variable to make sure it's not null before executing a conditional block of
    			code. However in the conditional block it reassigns the local variable. It is likely that the guard
    			should have been a check to see if the local variable is null, not that the local variable was not null.</p>
    			]]>
    		</Details>
	</BugPattern>

	<BugPattern type="MDM_RUNTIME_EXIT_OR_HALT">
		<ShortDescription>Method calls Runtime.exit() or Runtime.halt()</ShortDescription>
		<LongDescription>Method {1} calls {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Calling <code>Runtime.exit()</code> or <code>Runtime.halt()</code> shuts down the entire Java virtual machine. This should only been done when it is appropriate. Such calls make it hard or impossible for your code to be invoked by other code. Consider throwing a RuntimeException instead.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_RUNFINALIZATION">
		<ShortDescription>Method triggers finalization</ShortDescription>
		<LongDescription>Method {1} triggers finalization when calling {2}</LongDescription>
		<Details>
		<![CDATA[
		<p>Manually triggering finalization can result in serious performance problems and may be masking resource cleanup bugs.</p>
		]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_BIGDECIMAL_EQUALS">
		<ShortDescription>Method calls BigDecimal.equals()</ShortDescription>
		<LongDescription>Method {1} calls BigDecimal.equals(), which is normally a mistake</LongDescription>
		<Details>
		<![CDATA[
		<p><code>equals()</code> being called to compare two <code>java.math.BigDecimal</code> numbers. This is normally a mistake, as two <code>BigDecimal</code> objects are only equal if they are equal in both value and scale, so that <i>2.0</i> is not equal to <i>2.00</i>. To compare <code>BigDecimal</code> objects for mathematical equality, use <code>compareTo()</code> instead.</p>
		]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_INETADDRESS_GETLOCALHOST">
		<ShortDescription>Method calls InetAddress.getLocalHost()</ShortDescription>
		<LongDescription>Method {1} calls InetAddress.getLocalHost(), which may be a security risk</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Do not call <code>InetAddress.getLocalHost()</code> on multihomed servers. On a multihomed server, <code>InetAddress.getLocalHost()</code> simply returns the IP address associated with the server's internal hostname. This could be any of the network interfaces, which could expose the machine to security risks. Server applications that need to listen on sockets should add configurable properties to define which network interfaces the server should bind.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_PROMISCUOUS_SERVERSOCKET">
		<ShortDescription>Method creates promiscuous ServerSocket object</ShortDescription>
		<LongDescription>Method {1} creates a promiscuous ServerSocket, which may be a security risk</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Do not use the <code>ServerSocket</code> constructor or <code>ServerSocketFactory.createServerSocket()</code> factory methods that accepts connections on any network interface. By default, an application that listens on a socket will listen for connection attempts on any network interface, which can be a security risk. Only the long form the <code>ServerSocket</code> constructor or <code>ServerSocketFactory.createServerSocket()</code> factory methods take a specific local address to define which network interface the socket should bind.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_RANDOM_SEED">
		<ShortDescription>Method creates insecure Random object</ShortDescription>
		<LongDescription>Method {1} creates an insecure Random object, which may be a security risk</LongDescription>
		<Details>
		  <![CDATA[
		  <p><code>Random()</code> constructor without a seed is insecure because it defaults to easily guessable seed: <code>System.currentTimeMillis()</code>. Initialize seed with <code>Random(SecureRandom.getInstance().generateSeed())</code> or use <code>SecureRandom</code> instead.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SECURERANDOM">
		<ShortDescription>Method calls deprecated SecureRandom method</ShortDescription>
		<LongDescription>Method {1} calls deprecated SecureRandom method {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>The <code>SecureRandom()</code> constructors and <code>SecureRandom.getSeed()</code> method are deprecated. Call <code>SecureRandom.getInstance()</code> and <code>SecureRandom.getInstance().generateSeed()</code> instead.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_PRIORITIES">
		<ShortDescription>Method uses suspicious thread priorities</ShortDescription>
		<LongDescription>Method {1} uses suspicious thread priorities by calling method {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Getting or setting thread priorities is not portable and could cause or mask race conditions.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_YIELD">
		<ShortDescription>Method attempts to manually schedule threads</ShortDescription>
		<LongDescription>Method {1} attempts to manually schedule threads by calling method {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Manual thread scheduling with <code>Thread.sleep()</code> or <code>Thread.yield()</code> has no guaranteed semantics and is often used to mask race conditions.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_WAIT_WITHOUT_TIMEOUT">
		<ShortDescription>Method sleeps without timeout</ShortDescription>
		<LongDescription>Method {1} sleeps without timeout when calling {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Calling <code>{2}</code> without timeout could block forever. Consider using a timeout to detect deadlocks or performance problems. Thread.join() Object.wait() Condition.await() Lock.lock() Lock.lockInterruptibly()</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_FAIRNESS">
		<ShortDescription>Method ignores Lock's fairness settings by calling tryLock()</ShortDescription>
		<LongDescription>Method {1} ignores Lock's fairness settings by calling {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Calling <code>Lock.tryLock()</code> or <code>ReentrantLock.tryLock()</code> without a timeout does not honor the lock's fairness setting. If you want to honor the fairness setting for this lock, then use <code>tryLock(0, TimeUnit.SECONDS)</code> which is almost equivalent (it also detects interruption).</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SIGNAL_NOT_SIGNALALL">
		<ShortDescription>Method calls Condition.signal() rather than Condition.signalAll()</ShortDescription>
		<LongDescription>Method {1} calls Condition.signal() rather than Condition.signalAll()</LongDescription>
		<Details>
		  <![CDATA[
		  <p><code>Condition.signalAll()</code> is prefered over <code>Condition.signal()</code>. Calling <code>signal()</code> only wakes up one thread, meaning that the thread woken up might not be the one waiting for the condition that the caller just satisfied.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_LOCK_ISLOCKED">
		<ShortDescription>Method tests if a lock is locked</ShortDescription>
		<LongDescription>Method {1} tests if a lock is locked by calling {2}</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Calling <code>ReentrantLock.isLocked()</code> or <code>ReentrantLock.isHeldByCurrentThread()</code> might indicate race conditions or incorrect locking. These methods are designed for use in debug code or monitoring of the system state, not for synchronization control.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_STRING_BYTES_ENCODING">
		<ShortDescription>Method encodes String bytes without specifying the character encoding</ShortDescription>
		<LongDescription>Method {1} encodes String bytes without specifying the character encoding</LongDescription>
		<Details>
		  <![CDATA[
		  <p>The behavior of the <code>String(byte[] bytes)</code> and <code>String.getBytes()</code> is undefined if the string cannot be encoded in the platform's default charset. Instead, use the <code>String(byte[] bytes, String encoding)</code> or <code>String.getBytes(String encoding)></code> constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SETDEFAULTLOCALE">
		<ShortDescription>Method calls Locale.setDefault()</ShortDescription>
		<LongDescription>Method {1} calls Locale.setDefault(), changing locale for all threads</LongDescription>
		<Details>
		  <![CDATA[
		  <p>Do not use the <code>Locale.setDefault()</code> method to change the default locale. It changes the JVM's default locale for all threads and makes your applications unsafe to threads. It does not affect the host locale. Since changing the JVM's default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine, such as the user interface.</p>
		  ]]>
		</Details>
	</BugPattern>

	<BugPattern type="ROOM_REFLECTION_ON_OBJECT_METHODS">
		<ShortDescription>Method uses reflection to call a method available on java.lang.Object</ShortDescription>
		<LongDescription>Method {1} uses reflection to call a method available on java.lang.Object</LongDescription>
		<Details>
			<![CDATA[
				<p>This method uses reflection to call a method that is defined in java.lang.Object.
				As these methods are always available, it is not necessary to call these methods with
				reflection.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IPU_IMPROPER_PROPERTIES_USE">
		<ShortDescription>Method puts non-String values into a Properties object</ShortDescription>
		<LongDescription>Method {1} puts non-String values into a Properties object</LongDescription>
		<Details>
			<![CDATA[
				<p>This method places non-String objects into a Properties object. As the Properties object
				is intented to be a String to String map, putting non String objects is wrong, and takes advantage
				of a design flaw in the Properties class by deriving from Hashtable instead of using aggregation.
				If you want a collection that holds other types of objects, use a Hashtable, or better still newer collections
				like HashMap or TreeMap.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IPU_IMPROPER_PROPERTIES_USE_SETPROPERTY">
		<ShortDescription>Method uses Properties.put instead of Properties.setProperty</ShortDescription>
		<LongDescription>Method {1} uses Properties.put instead of Properties.setProperty</LongDescription>
		<Details>
			<![CDATA[
				<p>This method uses the inherited method from Hashtable put(String key, Object value) in
				a Properties object. Since the Properties object was intended to be only a String to String
				map, use of the derived put method is discouraged. Use the Properties.setProperty method instead.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PCAIL_POSSIBLE_CONSTANT_ALLOCATION_IN_LOOP">
		<ShortDescription>Method allocates an object that is used in a constant way in a loop</ShortDescription>
		<LongDescription>Method {1} allocates an object that is used in a constant way in a loop</LongDescription>
		<Details>
			<![CDATA[
				<p>This method allocates an object using the default constructor in a loop, and then
				only uses it in a quasi-static way. It is never assigned to anything that lives outside
				the loop, and could potentially be allocated once outside the loop. Often this can be 
				achieved by calling a clear() like method in the loop, to reset the state of the object
				in the loop.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WOC_WRITE_ONLY_COLLECTION_LOCAL">
		<ShortDescription>Method creates and initializes a collection but never reads or gains information from it</ShortDescription>
		<LongDescription>Method {1} creates and initializes a collection but never reads or gains information from it</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates and initializes a collection but then never access this collection
				to gain information, or fetch items from the collection. It is likely that this collection
				is left over from a past effort, and can be removed.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WOC_WRITE_ONLY_COLLECTION_FIELD">
		<ShortDescription>Class creates and initializes a collection but never reads or gains information from it</ShortDescription>
		<LongDescription>Class {0} creates and initializes a collection but never reads or gains information from it</LongDescription>
		<Details>
			<![CDATA[
				<p>This class creates and initializes a collection as a field but then never access this collection
				to gain information, or fetch items from the collection. It is likely that this collection
				is left over from a past effort, and can be removed.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UVA_USE_VAR_ARGS">
		<ShortDescription>Method defines parameter list with array as last argument, rather than vararg</ShortDescription>
		<LongDescription>Method {1} defines parameter list with array as last argument, rather than vararg</LongDescription>
		<Details>
			<![CDATA[
				<p>This method defines a parameter list that ends with an array. As this class is compiled with
				Java 1.5 or better, this parameter could be defined as a vararg parameter instead, which can be
				more convienent for client developers to use. This is not a bug, per se, just an improvement.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PUS_POSSIBLE_UNSUSPECTED_SERIALIZATION">
		<ShortDescription>Method serializes an instance of a non-static inner class</ShortDescription>
		<LongDescription>Method {1} serializes an instance of a non-static inner class</LongDescription>
		<Details>
			<![CDATA[
				<p>This method serializes an instance of a non-static inner class. Since this class has a
				reference to the containing class, this outer class will be serialized as well. This is often
				not intentional, and will make the amount of data that is serialized much more than is needed.
				If the outer classes is not desired to be serialized, either make the inner class, static, or 
				pull it out into a separate "first class" class.
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="SEC_SIDE_EFFECT_CONSTRUCTOR">
		<ShortDescription>Method uses a Side Effect Constructor</ShortDescription>
		<LongDescription>Method {1} uses a Side Effect Constructor</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates an object but does not assign this object to any variable or field.
				This implies that the class operates through side effects in the constructor, which is a 
				bad pattern to use, as it adds unnecessary coupling. Consider pulling the side effect out of 
				the constructor, into a separate method, or into the calling method.
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="SGSU_SUSPICIOUS_GETTER_SETTER_USE">
		<ShortDescription>Method uses same bean's getter value for setter</ShortDescription>
		<LongDescription>Method {1} uses same bean's getter value for setter</LongDescription>
		<Details>
			<![CDATA[
				<p>This method retrieves the property of a java bean, only to use it in the setter
				for the same property of the same bean. This is usually a copy/paste typo.
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="LGO_LINGERING_GRAPHICS_OBJECT">
		<ShortDescription>Method allocations a java.awt.Graphics object without disposing it</ShortDescription>
		<LongDescription>Method {1} allocations a java.awt.Graphics object without disposing it</LongDescription>
		<Details>
			<![CDATA[
				<p>This method allocates a java.awt.Graphics object but doesn't dispose of it when done. While
				the garbage collecter will clean this up, given that a large number of Graphics objects can be
				created in a short period of time, it is recommended that you explicitly dispose() of them.
				</p>
			]]>
		</Details>
	</BugPattern>
	
	<BugPattern type="STB_STACKED_TRY_BLOCKS">
		<ShortDescription>Method stacks similar try/catch blocks</ShortDescription>
		<LongDescription>Method {1} stacks similar try/catch blocks</LongDescription>
		<Details>
			<![CDATA[
				<P>This method declares two try catch blocks one after another, where each 
				catch block catches the same type of exception. They also throw uniformly the
				same type of exception. These two catch blocks can be combined into one to
				simplify the method.</p>
			]]>
		</Details>
	</BugPattern>

    <BugPattern type="CEBE_COMMONS_EQUALS_BUILDER_ISEQUALS">
        <ShortDescription>Method returns the result of invoking equals() on EqualsBuilder</ShortDescription>
        <LongDescription>Method {1} returns the result of invoking equals() in EqualsBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>This method returns the result of equals on the EqualsBuilder type
            instead of calling the method isEqual().</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CHTH_COMMONS_HASHCODE_BUILDER_TOHASHCODE">
        <ShortDescription>Method returns the result of invoking hashCode() on HashCodeBuilder</ShortDescription>
        <LongDescription>Method {1} returns the result of invoking hashCode() in HashCodeBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>This method returns the result of hashCode on the HashCodeBuilder type
            instead of calling the method toHashCode().</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="CSBTS_COMMONS_STRING_BUILDER_TOSTRING">
        <ShortDescription>Method returns the result of invoking toString() without intermediate invocation of append() in ToStringBuilder</ShortDescription>
        <LongDescription>Method {1} returns the result of invoking toString() without intermediate invocation of append() in ToStringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>This method returns the result of toString() on ToStringBuilder without an
            intermediate invocation of append()</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="CCNE_COMPARE_CLASS_EQUALS_NAME">
        <ShortDescription>Method compares class name instead of comparing class</ShortDescription>
        <LongDescription>Method {1} compares class name instead of comparing the class</LongDescription>
        <Details>
            <![CDATA[
            <p> In a JVM, Two classes are the same class (and consequently the same type) if
            they are loaded by the same class loader, and they have the same fully
            qualified name [JVMSpec 1999].
            
            Comparing class name ignores the class loader.
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="BRPI_BACKPORT_REUSE_PUBLIC_IDENTIFIERS">
        <ShortDescription>Method uses backport concurrency utils</ShortDescription>
        <LongDescription>Method {1} backport concurrency utils</LongDescription>
        <Details>
            <![CDATA[
            <p> This class usees Backport Utils concurrent classes. Updated/Efficient version of these
            classes are available in versions of the JDK 5.0 and higher, and these
            classes should only be used if you are targeting JDK 1.4 and lower.
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="CU_CLONE_USABILITY_OBJECT_RETURN">
        <ShortDescription>Clone method declares it returns an Object</ShortDescription>
        <LongDescription>Clone method {1} declares it returns an Object</LongDescription>
        <Details>
            <![CDATA[
            <p> This class implements the Cloneable interface but defines its clone method to return an 
            Object. Since most likely users of this method will need to cast it to the real type, this will
            be more painful than necessary. Just declare the return value to be the type of this class.
            </p>
            ]]>
        </Details>
    </BugPattern>
        
    <BugPattern type="CU_CLONE_USABILITY_THROWS">
        <ShortDescription>Clone method declares it throws CloneNotSupportedException</ShortDescription>
        <LongDescription>Clone method {1} declares it throws CloneNotSupportedException</LongDescription>
        <Details>
            <![CDATA[
            <p> This class implements the Cloneable interface but defines its clone method to still return
            a CloneNotSupportedException. Since you are implementing clone() it would make sense that the method
            in question will _not_ throw that exception, so annotating your method with it just makes client use
            of your more painful as they have to handle an exception that will never happen. Just remove the 
            throws clause from your method.
            </p>
            ]]>
        </Details>
    </BugPattern>   
    
    <BugPattern type="CAAL_CONFUSING_ARRAY_AS_LIST">
        <ShortDescription>Method calls Array.asList on an array of primitive values</ShortDescription>
        <LongDescription>Method {1} calls Array.asList on an array of primitive values</LongDescription>
        <Details>
            <![CDATA[
            <p> This method passes an array of primitive values to the Array.asList call. As primitive
            values in arrays aren't automatically promoted to boxed primitives in arrays, the asList call
            cannot convert this array in a list of boxed primitives. It therefore just creates an array
            with one item in it, the array itself. This is rarely what is desired.
            </p>
            ]]>
        </Details>
    </BugPattern> 
    
    <BugPattern type="PSC_PRESIZE_COLLECTIONS">
        <ShortDescription>Method does not presize the allocation of a collection</ShortDescription>
        <LongDescription>Method {1} does not presize the allocation of a collection</LongDescription>
        <Details>
            <![CDATA[
            <p> This method allocates a collection using the default constructor even though it is known
            apriori how many items are going to be placed in the collection (or at least a reasonable guess)
            and thus needlessly causes intermediate reallocations of the collection.
            </p>
            ]]>
        </Details>
    </BugPattern>"
   
	<!-- BugCode -->

	<BugCode abbrev="ISB">Inefficient String Buffering</BugCode>
	<BugCode abbrev="SCI">Synchronized Collection Iterators</BugCode>
	<BugCode abbrev="CC">Cyclomatic Complexity</BugCode>
	<BugCode abbrev="OCP">Overly Concrete Parameters</BugCode>
	<BugCode abbrev="LII">List Indexed Iterating</BugCode>
	<BugCode abbrev="UCC">Unrelated Collection Contents</BugCode>
	<BugCode abbrev="DRE">Declared Runtime Exception</BugCode>
	<BugCode abbrev="CE">Class Envy</BugCode>
	<BugCode abbrev="LSC">Literal String Comparison</BugCode>
	<BugCode abbrev="PCOA">Partially Constructed Object Access</BugCode>
	<BugCode abbrev="DLC">Dubious List Collection</BugCode>
	<BugCode abbrev="PL">Parallel Lists</BugCode>
	<BugCode abbrev="FP">Final Parameters</BugCode>
	<BugCode abbrev="ACEM">Abstract Class Empty Methods</BugCode>
	<BugCode abbrev="MAC">Manual Array Copy</BugCode>
	<BugCode abbrev="FPL">Floating Point Loops</BugCode>
	<BugCode abbrev="NCMU">Non Collection Method Use</BugCode>
	<BugCode abbrev="CAO">Confusing Autoboxed Overloading</BugCode>
	<BugCode abbrev="AFBR">Abnormal Finally Block Return</BugCode>
	<BugCode abbrev="SMII">Static Method Instance Invocation</BugCode>
	<BugCode abbrev="STS">Spurious Thread States</BugCode>
	<BugCode abbrev="NAB">Needless Autoboxing</BugCode>
	<BugCode abbrev="USBR">Unnecessary Store Before Return</BugCode>
	<BugCode abbrev="COM">Copied Overridden Method</BugCode>
	<BugCode abbrev="ABC">Array Based Collection</BugCode>
	<BugCode abbrev="ODN">Orphaned DOM Node</BugCode>
	<BugCode abbrev="AOM">Abstract Overridden Method</BugCode>
	<BugCode abbrev="CBX">Custom Built XML</BugCode>
	<BugCode abbrev="BSB">Bloated Synchronized Block</BugCode>
	<BugCode abbrev="CLI">Constant List Index</BugCode>
	<BugCode abbrev="SCR">Sloppy Class Reflection</BugCode>
	<BugCode abbrev="AWCBR">Array Wrapped Call By Reference</BugCode>
	<BugCode abbrev="SG">Sluggish Gui</BugCode>
	<BugCode abbrev="NIR">Needless Instance Retrieval</BugCode>
	<BugCode abbrev="DDC">Double Date comparison</BugCode>
	<BugCode abbrev="SWCO">Suspicious Wait on Concurrent Object</BugCode>
	<BugCode abbrev="JVR">JDBC Vendor Reliance</BugCode>
	<BugCode abbrev="PMB">Possible Memory Bloat</BugCode>
	<BugCode abbrev="LSYC">Local Synchronized Collection</BugCode>
	<BugCode abbrev="FCBL">Field Could Be Local</BugCode>
	<BugCode abbrev="NOS">Non Owned Synchronization</BugCode>
	<BugCode abbrev="NRTL">Non Recycleable Taglib</BugCode>
	<BugCode abbrev="S508C">Section 508 Compliance Violations</BugCode>
	<BugCode abbrev="UEC">Use Enum Collections</BugCode>
	<BugCode abbrev="SIL">SQL In Loop</BugCode>
	<BugCode abbrev="NMCS">Needless Member Collection Synchronization</BugCode>
	<BugCode abbrev="ITC">Inheritance Type Checking</BugCode>
	<BugCode abbrev="SACM">Static Array Created in Method</BugCode>
	<BugCode abbrev="PRMC">Possibly Redundant Method Calls</BugCode>
	<BugCode abbrev="UTA">Use toArray</BugCode>
	<BugCode abbrev="LEST">Lost Exception Stack Trace</BugCode>
	<BugCode abbrev="UCPM">Use Character Parameterized Method</BugCode>
	<BugCode abbrev="TR">Tail Recursion</BugCode>
	<BugCode abbrev="URV">Unrelated Return Values</BugCode>
	<BugCode abbrev="PIS">Possible Incomplete Serialization</BugCode>
	<BugCode abbrev="SCRV">Suspicious Comparator Return Values</BugCode>
	<BugCode abbrev="SPP">Sillyness Pot Pourri</BugCode>
	<BugCode abbrev="BAS">Bloated Assignment Scope</BugCode>
	<BugCode abbrev="SCII">Spoiled Child Interface Implementor</BugCode>
	<BugCode abbrev="DWI">Deleting While Iterating</BugCode>
	<BugCode abbrev="USS">Use String Split</BugCode>
	<BugCode abbrev="SJVU">Suspicious JDK Version Use</BugCode>
	<BugCode abbrev="UAA">Use Add All</BugCode>
	<BugCode abbrev="MRC">Method Returns Constant</BugCode>
	<BugCode abbrev="NCS">Needless Custom Serialization</BugCode>
	<BugCode abbrev="MOM">Misleading Overload Model</BugCode>
	<BugCode abbrev="EXS">Exception Softening</BugCode>
	<BugCode abbrev="CFS">Confusing Function Semantics</BugCode>
	<BugCode abbrev="JAO">JUnit Assertion Oddities</BugCode>
	<BugCode abbrev="SCA">Suspicious Clone Algorithm</BugCode>
	<BugCode abbrev="WEM">Weak Exception Messaging</BugCode>
	<BugCode abbrev="SCSS">Suspicious Clustered Session Support</BugCode>
	<BugCode abbrev="LO">Logger Oddities</BugCode>
	<BugCode abbrev="IICU">Incorrect Internal Class use</BugCode>
	<BugCode abbrev="DSOC">Dubious Set of Collections</BugCode>
	<BugCode abbrev="BED">Bogus Exception Declaration</BugCode>
	<BugCode abbrev="UNNC">Unnecessary New Null Check</BugCode>
	<BugCode abbrev="DTEP">Deprecated Typesafe Enum Pattern</BugCode>
	<BugCode abbrev="SMA">Stuttered Method Arguments</BugCode>
	<BugCode abbrev="TBP">Tristate Boolean Pattern</BugCode>
	<BugCode abbrev="SUA">Suspicious Uninitialized Array</BugCode>
	<BugCode abbrev="ITU">Inappropriate toString Use</BugCode>
	<BugCode abbrev="IKNC">Inconsistent Key Name Casing</BugCode>
	<BugCode abbrev="OC">Overzealous Casting</BugCode>
	<BugCode abbrev="PDP">Poorly Defined Parameter</BugCode>
	<BugCode abbrev="NSE">Non Symmetric Equals</BugCode>
	<BugCode abbrev="CVAA">Contravariant Array Assignment</BugCode>
	<BugCode abbrev="NFF">Non Functional Field</BugCode>
	<BugCode abbrev="SNG">Suspicious Null Guard</BugCode>
	<BugCode abbrev="MDM">More Dumb Methods</BugCode>
	<BugCode abbrev="ROOM">Reflection on Object Methods</BugCode>
	<BugCode abbrev="IPU">Improper Properties use</BugCode>
	<BugCode abbrev="PCAIL">Possible Constant Allocation In Loop</BugCode>
	<BugCode abbrev="WOC">Write Only Collection</BugCode>
	<BugCode abbrev="UVA">Use Var Args</BugCode>
	<BugCode abbrev="PUS">Possible Unsuspected Serialization</BugCode>
	<BugCode abbrev="SEC">Side Effect Constructor</BugCode>
	<BugCode abbrev="SGSU">Suspicious Getter Setter Use</BugCode>
	<BugCode abbrev="LGO">Lingering Graphics Object</BugCode>
	<BugCode abbrev="STB">Stacked Try Blocks</BugCode>
	<BugCode abbrev="CEBE">Commons EqualsBuilder To Equals</BugCode>
	<BugCode abbrev="CHTH">Commons HashCodeBuilder To hashCode</BugCode>
	<BugCode abbrev="CSBTS">Commons ToStringBuilder To String</BugCode>
    <BugCode abbrev="CCNE">Compare class name equals</BugCode>
    <BugCode abbrev="BRPI">Backport concurrent reuse of public identifiers</BugCode>
    <BugCode abbrev="CU">Clone Usability</BugCode>
    <BugCode abbrev="CAAL">Confusing Array asList</BugCode>
    <BugCode abbrev="PSC">Presize Collection</BugCode>
</MessageCollection>
